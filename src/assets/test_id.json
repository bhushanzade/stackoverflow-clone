{"items":[{"tags":["java","c++","performance","optimization","branch-prediction"],"comments":[{"owner":{"badge_counts":{"bronze":24,"silver":6,"gold":0},"reputation":1295,"user_id":1300177,"user_type":"registered","accept_rate":93,"profile_image":"https://www.gravatar.com/avatar/4996dd0400f07c6dd5776f5498c04aea?s=128&d=identicon&r=PG","display_name":"screwnut","link":"https://stackoverflow.com/users/1300177/screwnut"},"edited":false,"score":55,"creation_date":1525389149,"post_id":11227809,"comment_id":87347917,"content_license":"CC BY-SA 4.0","body":"For the record, your data need not be sorted, only <a href=\"https://en.cppreference.com/w/cpp/algorithm/partition\" rel=\"nofollow noreferrer\">partitioned</a> which is a much faster operation."},{"owner":{"badge_counts":{"bronze":9,"silver":3,"gold":1},"reputation":270,"user_id":5649936,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/0603f8b9920243e03e06c3e15eb77a8a?s=128&d=identicon&r=PG&f=1","display_name":"Šimon Hrabec","link":"https://stackoverflow.com/users/5649936/%c5%a0imon-hrabec"},"edited":false,"score":25,"creation_date":1526042708,"post_id":11227809,"comment_id":87601479,"content_license":"CC BY-SA 4.0","body":"Another observation is that you don&#39;t need to sort the array, but you just need to partition it with the value 128. Sorting is n*log(n), whereas partitioning is just linear. Basically it is just one run of the quick sort partitioning step with the pivot chosen to be 128. Unfortunately in C++ there is just nth_element function, which partition by position, not by value."},{"owner":{"badge_counts":{"bronze":49,"silver":38,"gold":2},"reputation":7134,"user_id":58668,"user_type":"registered","accept_rate":39,"profile_image":"https://www.gravatar.com/avatar/553fdb376e001fa69adb6b8046fd6a14?s=128&d=identicon&r=PG","display_name":"Jonas K&#246;lker","link":"https://stackoverflow.com/users/58668/jonas-k%c3%b6lker"},"reply_to_user":{"badge_counts":{"bronze":24,"silver":6,"gold":0},"reputation":1295,"user_id":1300177,"user_type":"registered","accept_rate":93,"profile_image":"https://www.gravatar.com/avatar/4996dd0400f07c6dd5776f5498c04aea?s=128&d=identicon&r=PG","display_name":"screwnut","link":"https://stackoverflow.com/users/1300177/screwnut"},"edited":false,"score":3,"creation_date":1601886376,"post_id":11227809,"comment_id":113534273,"content_license":"CC BY-SA 4.0","body":"@screwnut here&#39;s an experiment which would show that partitioning is sufficient: create an unsorted but partitioned array with otherwise random contents. Measure time. Sort it. Measure time again. The two measurements should be basically indistinguishable. (Experiment 2: create a random array. Measure time. Partition it. Measure time again. You should see the same speed-up as sorting. You could roll the two experiments into one.)"},{"owner":{"badge_counts":{"bronze":14,"silver":2,"gold":1},"reputation":336,"user_id":11041430,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/ba8e6b52b3f40b3c55d1730c199c0f19?s=128&d=identicon&r=PG&f=1","display_name":"D. Sikilai","link":"https://stackoverflow.com/users/11041430/d-sikilai"},"edited":false,"score":2,"creation_date":1606488099,"post_id":11227809,"comment_id":114983452,"content_license":"CC BY-SA 4.0","body":"I think this question is old enough to be deleted. Things have changed there is very LITTLE difference this days."},{"owner":{"badge_counts":{"bronze":15,"silver":1,"gold":0},"reputation":283,"user_id":14173388,"user_type":"registered","profile_image":"https://i.stack.imgur.com/n9sxz.jpg?s=128&g=1","display_name":"Ahmad","link":"https://stackoverflow.com/users/14173388/ahmad"},"reply_to_user":{"badge_counts":{"bronze":14,"silver":2,"gold":1},"reputation":336,"user_id":11041430,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/ba8e6b52b3f40b3c55d1730c199c0f19?s=128&d=identicon&r=PG&f=1","display_name":"D. Sikilai","link":"https://stackoverflow.com/users/11041430/d-sikilai"},"edited":false,"score":3,"creation_date":1609198556,"post_id":11227809,"comment_id":115775724,"content_license":"CC BY-SA 4.0","body":"yea i would have to agree with @D.Sikilai there is little difference these days but its still a good post to look back on"},{"owner":{"badge_counts":{"bronze":3,"silver":0,"gold":0},"reputation":66,"user_id":13813640,"user_type":"registered","profile_image":"https://lh6.googleusercontent.com/-1YGpBoxyZXY/AAAAAAAAAAI/AAAAAAAAAAA/AMZuucnKFSaYa2VfUWeoImOmuM4Mm6IHnQ/photo.jpg?sz=128","display_name":"Roman Yavorskyi","link":"https://stackoverflow.com/users/13813640/roman-yavorskyi"},"reply_to_user":{"badge_counts":{"bronze":14,"silver":2,"gold":1},"reputation":336,"user_id":11041430,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/ba8e6b52b3f40b3c55d1730c199c0f19?s=128&d=identicon&r=PG&f=1","display_name":"D. Sikilai","link":"https://stackoverflow.com/users/11041430/d-sikilai"},"edited":false,"score":1,"creation_date":1616524484,"post_id":11227809,"comment_id":118028174,"content_license":"CC BY-SA 4.0","body":"@D.Sikilai can you please clarify what has changed?"}],"answers":[{"comments":[{"owner":{"badge_counts":{"bronze":18,"silver":8,"gold":0},"reputation":1151,"user_id":538458,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/737d082cd41a6c7caac7f98c3797d50c?s=128&d=identicon&r=PG","display_name":"Adam Freeman","link":"https://stackoverflow.com/users/538458/adam-freeman"},"edited":false,"score":130,"creation_date":1411498692,"post_id":11227877,"comment_id":40722655,"content_license":"CC BY-SA 3.0","body":"Does branch prediction work better on sorted arrays vs. arrays with different patterns?  For example, for the array --&gt; { 10, 5, 20, 10, 40, 20, ... } the next element in the array from the pattern is 80.  Would this kind of array be sped up by branch prediction in which the next element is 80 here if the pattern is followed?  Or does it usually only help with sorted arrays?"},{"owner":{"badge_counts":{"bronze":38,"silver":20,"gold":4},"reputation":2684,"user_id":3206624,"user_type":"registered","accept_rate":94,"profile_image":"https://www.gravatar.com/avatar/95b1b5df80d9d891b48d668af975be84?s=128&d=identicon&r=PG&f=1","display_name":"Agrim Pathak","link":"https://stackoverflow.com/users/3206624/agrim-pathak"},"edited":false,"score":167,"creation_date":1414655518,"post_id":11227877,"comment_id":41900025,"content_license":"CC BY-SA 3.0","body":"So basically everything I conventionally learned about big-O is out of the window?  Better to incur a sorting cost than a branching cost?"},{"owner":{"badge_counts":{"bronze":422,"silver":292,"gold":16},"reputation":173927,"user_id":1011995,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Jca5Q.jpg?s=128&g=1","display_name":"Daniel Fischer","link":"https://stackoverflow.com/users/1011995/daniel-fischer"},"reply_to_user":{"badge_counts":{"bronze":38,"silver":20,"gold":4},"reputation":2684,"user_id":3206624,"user_type":"registered","accept_rate":94,"profile_image":"https://www.gravatar.com/avatar/95b1b5df80d9d891b48d668af975be84?s=128&d=identicon&r=PG&f=1","display_name":"Agrim Pathak","link":"https://stackoverflow.com/users/3206624/agrim-pathak"},"edited":false,"score":158,"creation_date":1414664052,"post_id":11227877,"comment_id":41904388,"content_license":"CC BY-SA 3.0","body":"@AgrimPathak That depends. For not too large input, an algorithm with higher complexity is faster than an algorithm with lower complexity when the constants are smaller for the algorithm with higher complexity. Where the break-even point is can be hard to predict. Also, <a href=\"http://stackoverflow.com/questions/14023988/why-is-processing-a-sorted-array-slower-than-an-unsorted-array?lq=1\">compare this</a>, locality is important. Big-O is important, but it is not the sole criterion for performance."},{"owner":{"badge_counts":{"bronze":90,"silver":42,"gold":4},"reputation":4977,"user_id":2047418,"user_type":"registered","accept_rate":83,"profile_image":"https://www.gravatar.com/avatar/1d49bccfa9d2c633db6f854e67b88362?s=128&d=identicon&r=PG","display_name":"Filip Bartuzi","link":"https://stackoverflow.com/users/2047418/filip-bartuzi"},"edited":false,"score":83,"creation_date":1415540238,"post_id":11227877,"comment_id":42224805,"content_license":"CC BY-SA 3.0","body":"When does branch prediction takes place? When does language will know that array is sorted? I&#39;m thinking of situation of array that looks like: [1,2,3,4,5,...998,999,1000, 3, 10001, 10002] ? will this obscure 3 increase running time? Will it be as long as unsorted array?"},{"owner":{"badge_counts":{"bronze":422,"silver":292,"gold":16},"reputation":173927,"user_id":1011995,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Jca5Q.jpg?s=128&g=1","display_name":"Daniel Fischer","link":"https://stackoverflow.com/users/1011995/daniel-fischer"},"reply_to_user":{"badge_counts":{"bronze":90,"silver":42,"gold":4},"reputation":4977,"user_id":2047418,"user_type":"registered","accept_rate":83,"profile_image":"https://www.gravatar.com/avatar/1d49bccfa9d2c633db6f854e67b88362?s=128&d=identicon&r=PG","display_name":"Filip Bartuzi","link":"https://stackoverflow.com/users/2047418/filip-bartuzi"},"edited":false,"score":79,"creation_date":1415540977,"post_id":11227877,"comment_id":42225007,"content_license":"CC BY-SA 3.0","body":"@FilipBartuzi Branch prediction takes place in the processor, below the language level (but the language may offer ways to tell the compiler what&#39;s likely, so the compiler can emit code suited to that). In your example, the out-of-order 3 will lead to a branch-misprediction (for appropriate conditions, where 3 gives a different result than 1000), and thus processing that array will likely take a couple dozen or hundred nanoseconds longer than a sorted array would, hardly ever noticeable. What costs time is i high rate of mispredictions, one misprediction per 1000 isn&#39;t much."},{"owner":{"badge_counts":{"bronze":103,"silver":72,"gold":12},"reputation":15430,"user_id":1715673,"user_type":"registered","accept_rate":86,"profile_image":"https://www.gravatar.com/avatar/dcd9836a94720caadd7dfc82d1df627d?s=128&d=identicon&r=PG","display_name":"Peter Wone","link":"https://stackoverflow.com/users/1715673/peter-wone"},"reply_to_user":{"badge_counts":{"bronze":18,"silver":8,"gold":0},"reputation":1151,"user_id":538458,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/737d082cd41a6c7caac7f98c3797d50c?s=128&d=identicon&r=PG","display_name":"Adam Freeman","link":"https://stackoverflow.com/users/538458/adam-freeman"},"edited":false,"score":3,"creation_date":1430452976,"post_id":11227877,"comment_id":48082367,"content_license":"CC BY-SA 3.0","body":"@AdamFreeman - Sorting is relevant here only inasmuch as <i>in this code</i> it increases branch prediction to 100% success."},{"owner":{"badge_counts":{"bronze":11,"silver":4,"gold":0},"reputation":259,"user_id":7886227,"user_type":"registered","profile_image":"https://i.stack.imgur.com/hec3U.jpg?s=128&g=1","display_name":"Dr t","link":"https://stackoverflow.com/users/7886227/dr-t"},"edited":false,"score":4,"creation_date":1495734693,"post_id":11227877,"comment_id":75387346,"content_license":"CC BY-SA 3.0","body":"I would recommend a look at: <a href=\"https://en.wikibooks.org/wiki/Optimizing_C%2B%2B/Writing_efficient_code/Performance_improving_features\" rel=\"nofollow noreferrer\">en.wikibooks.org/wiki/Optimizing_C%2B%2B/Writing_efficient_c&zwnj;&#8203;ode/&hellip;</a>  which provides a good discussion with examples of this topic including some that are not mentioned in any comments that i have seen regarding this question."},{"owner":{"badge_counts":{"bronze":24,"silver":18,"gold":2},"reputation":1842,"user_id":4285898,"user_type":"registered","accept_rate":75,"profile_image":"https://lh3.googleusercontent.com/-2RjNyl00QDA/AAAAAAAAAAI/AAAAAAAAARQ/FrNVhUUIMLw/photo.jpg?sz=128","display_name":"आनंद","link":"https://stackoverflow.com/users/4285898/%e0%a4%86%e0%a4%a8%e0%a4%82%e0%a4%a6"},"edited":false,"score":3,"creation_date":1505485014,"post_id":11227877,"comment_id":79447312,"content_license":"CC BY-SA 3.0","body":"@DanielFischer does compiler knows which array is sorted and which one is not?"},{"owner":{"badge_counts":{"bronze":8,"silver":4,"gold":1},"reputation":511,"user_id":1054647,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/05df494d41b7d14a22d7bff3959d531a?s=128&d=identicon&r=PG","display_name":"knickum","link":"https://stackoverflow.com/users/1054647/knickum"},"reply_to_user":{"badge_counts":{"bronze":24,"silver":18,"gold":2},"reputation":1842,"user_id":4285898,"user_type":"registered","accept_rate":75,"profile_image":"https://lh3.googleusercontent.com/-2RjNyl00QDA/AAAAAAAAAAI/AAAAAAAAARQ/FrNVhUUIMLw/photo.jpg?sz=128","display_name":"आनंद","link":"https://stackoverflow.com/users/4285898/%e0%a4%86%e0%a4%a8%e0%a4%82%e0%a4%a6"},"edited":false,"score":4,"creation_date":1507930981,"post_id":11227877,"comment_id":80423729,"content_license":"CC BY-SA 3.0","body":"@AnandTyagi As Peter Wone noted, it&#39;s not that the compiler knows which array is sorted or not. Imagine an extremely simple branch predictor that takes the same path as the previous iteration, e.g. a train taking a left if it took a left last time, and vice versa. For a sorted array of 256 ints, (ignoring the undefined first iteration), the prediction would be correct from 2-128, wrong at 129, and then correct from 130-256. Now, that&#39;s a terrible branch predictor that would only work in this specific situation, but a really good predictor should still handle this capably."},{"owner":{"badge_counts":{"bronze":18,"silver":6,"gold":0},"reputation":442,"user_id":1494680,"user_type":"registered","accept_rate":100,"profile_image":"https://www.gravatar.com/avatar/303668e5317cc07925197755ff3c10c4?s=128&d=identicon&r=PG","display_name":"Omer","link":"https://stackoverflow.com/users/1494680/omer"},"edited":false,"score":1,"creation_date":1593237458,"post_id":11227877,"comment_id":110714690,"content_license":"CC BY-SA 4.0","body":"Is the branch predictions mostly happen at compiler level or it is handled by processor? And why java or c++ can not handled it? I mean why is not complicated to predict it right?"}],"tags":[],"owner":{"badge_counts":{"bronze":422,"silver":292,"gold":16},"reputation":173927,"user_id":1011995,"user_type":"registered","profile_image":"https://i.stack.imgur.com/Jca5Q.jpg?s=128&g=1","display_name":"Daniel Fischer","link":"https://stackoverflow.com/users/1011995/daniel-fischer"},"last_editor":{"badge_counts":{"bronze":0,"silver":1,"gold":0},"reputation":1,"user_id":-1,"user_type":"moderator","profile_image":"https://www.gravatar.com/avatar/a007be5a61f6aa8f3e85ae2fc18dd66e?s=128&d=identicon&r=PG","display_name":"Community","link":"https://stackoverflow.com/users/-1/community"},"comment_count":10,"up_vote_count":4288,"is_accepted":false,"score":4269,"last_activity_date":1470383590,"last_edit_date":1592644375,"creation_date":1340805285,"answer_id":11227877,"question_id":11227809,"content_license":"CC BY-SA 4.0","body":"<p><strong>Branch prediction.</strong></p>\n<p>With a sorted array, the condition <code>data[c] &gt;= 128</code> is first <code>false</code> for a streak of values, then becomes <code>true</code> for all later values. That's easy to predict. With an unsorted array, you pay for the branching cost.</p>\n"},{"comments":[{"owner":{"badge_counts":{"bronze":11,"silver":1,"gold":0},"reputation":96,"user_id":13830841,"user_type":"registered","profile_image":"https://lh3.googleusercontent.com/a-/AOh14GiTKeJoO6XlvqYIKBwy8DomvzAr7NzTIFGCxDZw=k-s128","display_name":"Hanna Mcquaig","link":"https://stackoverflow.com/users/13830841/hanna-mcquaig"},"edited":false,"score":21,"creation_date":1593562286,"post_id":11227902,"comment_id":110823655,"content_license":"CC BY-SA 4.0","body":"this is all C++?"},{"owner":{"badge_counts":{"bronze":35,"silver":22,"gold":1},"reputation":3177,"user_id":4068240,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/1c35facdddfc74d23ee378790b905226?s=128&d=identicon&r=PG","display_name":"Clijsters","link":"https://stackoverflow.com/users/4068240/clijsters"},"reply_to_user":{"badge_counts":{"bronze":11,"silver":1,"gold":0},"reputation":96,"user_id":13830841,"user_type":"registered","profile_image":"https://lh3.googleusercontent.com/a-/AOh14GiTKeJoO6XlvqYIKBwy8DomvzAr7NzTIFGCxDZw=k-s128","display_name":"Hanna Mcquaig","link":"https://stackoverflow.com/users/13830841/hanna-mcquaig"},"edited":false,"score":95,"creation_date":1593597753,"post_id":11227902,"comment_id":110834702,"content_license":"CC BY-SA 4.0","body":"@HannaMcquaig I&#39;d guess that part where it says &quot;Java&quot; isn&#39;t C++, but I may be wrong."},{"owner":{"badge_counts":{"bronze":18,"silver":4,"gold":0},"reputation":783,"user_id":4416169,"user_type":"registered","accept_rate":100,"profile_image":"https://www.gravatar.com/avatar/062b5273d4d63fcd079d7a65010c1817?s=128&d=identicon&r=PG&f=1","display_name":"Matias Chara","link":"https://stackoverflow.com/users/4416169/matias-chara"},"edited":false,"score":9,"creation_date":1594597968,"post_id":11227902,"comment_id":111173010,"content_license":"CC BY-SA 4.0","body":"wait a second, doesnt shifting negative values to the right yield implementation-defined values? int t = (data[c] - 128) &gt;&gt; 31; sum += ~t &amp; data[c];"},{"owner":{"badge_counts":{"bronze":13,"silver":6,"gold":0},"reputation":753,"user_id":493759,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/c28651cc42b824155c6bc9a15a300fd8?s=128&d=identicon&r=PG","display_name":"Agoston Horvath","link":"https://stackoverflow.com/users/493759/agoston-horvath"},"reply_to_user":{"badge_counts":{"bronze":18,"silver":4,"gold":0},"reputation":783,"user_id":4416169,"user_type":"registered","accept_rate":100,"profile_image":"https://www.gravatar.com/avatar/062b5273d4d63fcd079d7a65010c1817?s=128&d=identicon&r=PG&f=1","display_name":"Matias Chara","link":"https://stackoverflow.com/users/4416169/matias-chara"},"edited":false,"score":2,"creation_date":1601973465,"post_id":11227902,"comment_id":113565282,"content_license":"CC BY-SA 4.0","body":"@MatiasChara it&#39;s really hidden, see <a href=\"https://en.wikipedia.org/wiki/Bitwise_operations_in_C#Right_shift_%3E%3E\" rel=\"nofollow noreferrer\">en.wikipedia.org/wiki/&hellip;</a> ; &quot;however most compilers will perform an arithmetic shift, causing the blank to be filled with the sign bit of the left operand&quot;. I guess it&#39;s a de-facto standard by now."},{"owner":{"badge_counts":{"bronze":60,"silver":44,"gold":9},"reputation":4405,"user_id":774575,"user_type":"registered","accept_rate":78,"profile_image":"https://i.stack.imgur.com/I2J58.png?s=128&g=1","display_name":"mins","link":"https://stackoverflow.com/users/774575/mins"},"edited":false,"score":14,"creation_date":1602857081,"post_id":11227902,"comment_id":113860806,"content_license":"CC BY-SA 4.0","body":"Incidently branch prediction failure can also be <a href=\"https://eprint.iacr.org/2006/288.pdf\" rel=\"nofollow noreferrer\">exploited by a program to obtain crypto keys being used by another program</a> on the same CPU core."},{"owner":{"badge_counts":{"bronze":3,"silver":0,"gold":0},"reputation":91,"user_id":2755896,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/4bb190997516356ce466d9bf6cc5172b?s=128&d=identicon&r=PG&f=1","display_name":"Max","link":"https://stackoverflow.com/users/2755896/max"},"edited":false,"score":0,"creation_date":1606433551,"post_id":11227902,"comment_id":114968453,"content_license":"CC BY-SA 4.0","body":"We used to always use C for maximum performance because there was so little overhead.  Today, performance depends heavily on picking the right algorithm, sorting data when optimal, better use of the cache, and branch prediction.  C still produces the fastest code, but does so only when programmers keep all of these things in mind and take advantage of the hardware."},{"owner":{"badge_counts":{"bronze":7,"silver":0,"gold":0},"reputation":67,"user_id":8736053,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/516a059907ce44673c7c18b92146d4a1?s=128&d=identicon&r=PG&f=1","display_name":"Mycotina","link":"https://stackoverflow.com/users/8736053/mycotina"},"edited":false,"score":1,"creation_date":1607419616,"post_id":11227902,"comment_id":115259910,"content_license":"CC BY-SA 4.0","body":"I have a hard time understanding the explanation. Because, even with branch predictor, isn&#39;t the computer still need to know if it guessed right or wrong in the end? Because if not, how will it know if it should do the rollback? And for knowing if it is right or wrong, isn&#39;t we need to compute the result of the if condition nonetheless? Which in the end, will consume the same resource without branch prediction, or even slower because we need to correct mistakes?"},{"owner":{"badge_counts":{"bronze":24,"silver":10,"gold":0},"reputation":1719,"user_id":10915534,"user_type":"registered","profile_image":"https://i.stack.imgur.com/IcLqB.jpg?s=128&g=1","display_name":"Ibnelaiq","link":"https://stackoverflow.com/users/10915534/ibnelaiq"},"reply_to_user":{"badge_counts":{"bronze":11,"silver":1,"gold":0},"reputation":96,"user_id":13830841,"user_type":"registered","profile_image":"https://lh3.googleusercontent.com/a-/AOh14GiTKeJoO6XlvqYIKBwy8DomvzAr7NzTIFGCxDZw=k-s128","display_name":"Hanna Mcquaig","link":"https://stackoverflow.com/users/13830841/hanna-mcquaig"},"edited":false,"score":1,"creation_date":1607497541,"post_id":11227902,"comment_id":115287811,"content_license":"CC BY-SA 4.0","body":"@HannaMcquaig Always has been"},{"owner":{"badge_counts":{"bronze":29,"silver":14,"gold":0},"reputation":1678,"user_id":899213,"user_type":"registered","accept_rate":92,"profile_image":"https://www.gravatar.com/avatar/1cecebaf65cdd9a8351fdda654e5bdac?s=128&d=identicon&r=PG","display_name":"Raphael","link":"https://stackoverflow.com/users/899213/raphael"},"reply_to_user":{"badge_counts":{"bronze":7,"silver":0,"gold":0},"reputation":67,"user_id":8736053,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/516a059907ce44673c7c18b92146d4a1?s=128&d=identicon&r=PG&f=1","display_name":"Mycotina","link":"https://stackoverflow.com/users/8736053/mycotina"},"edited":false,"score":5,"creation_date":1609861882,"post_id":11227902,"comment_id":115951193,"content_license":"CC BY-SA 4.0","body":"@Mycotina, I&#39;m no expert, but what I understand is: the processor needs multiple steps to execute a single instruction (fetching, decoding, etc) -- this is called &quot;instruction pipelining&quot; -- so, as an optimization, it will fetch multiple instructions at once and &quot;warm up&quot; the next instructions while executing the current one. If the wrong branch is chosen, the instructions being &quot;warmed up&quot; in the pipeline must be discarded, so that the instructions on the right branch can be put into the pipeline instead."},{"owner":{"badge_counts":{"bronze":128,"silver":68,"gold":9},"reputation":58652,"user_id":1322972,"user_type":"registered","profile_image":"https://i.stack.imgur.com/puZFr.png?s=128&g=1","display_name":"WhozCraig","link":"https://stackoverflow.com/users/1322972/whozcraig"},"reply_to_user":{"badge_counts":{"bronze":7,"silver":0,"gold":0},"reputation":67,"user_id":8736053,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/516a059907ce44673c7c18b92146d4a1?s=128&d=identicon&r=PG&f=1","display_name":"Mycotina","link":"https://stackoverflow.com/users/8736053/mycotina"},"edited":false,"score":1,"creation_date":1610071437,"post_id":11227902,"comment_id":116023390,"content_license":"CC BY-SA 4.0","body":"@Mycotina It&#39;s easier to understand when you think of the instruction pipeline cache as tracks, the train (with cars) as the instructions, and the indicator of whether you go left or right by some dude at the END of the train; not the beginning. By the time you see him to know you&#39;ve guessed right, not only is it too late to switch things, the pipeline ahead is already populated, but in the wrong direction. If you guessed wrong the predicted pipeline needs to be thrown out (derail the train; drag it back before the switch house, put it back on the tracks, and send it the other way)."},{"owner":{"badge_counts":{"bronze":11,"silver":2,"gold":0},"reputation":343,"user_id":10220019,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/f1b2e39d80ba5e709c2c81017833b54d?s=128&d=identicon&r=PG&f=1","display_name":"C. Binair","link":"https://stackoverflow.com/users/10220019/c-binair"},"edited":false,"score":0,"creation_date":1614788479,"post_id":11227902,"comment_id":117493367,"content_license":"CC BY-SA 4.0","body":"I hope this question is simple, but I&#39;m confused. The prediction is that made during runtime or already when compiling?"},{"owner":{"badge_counts":{"bronze":8,"silver":0,"gold":0},"reputation":145,"user_id":8132066,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/e935e7c928e9eb139122eeceab4088ca?s=128&d=identicon&r=PG","display_name":"Tom","link":"https://stackoverflow.com/users/8132066/tom"},"reply_to_user":{"badge_counts":{"bronze":11,"silver":2,"gold":0},"reputation":343,"user_id":10220019,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/f1b2e39d80ba5e709c2c81017833b54d?s=128&d=identicon&r=PG&f=1","display_name":"C. Binair","link":"https://stackoverflow.com/users/10220019/c-binair"},"edited":false,"score":2,"creation_date":1615387664,"post_id":11227902,"comment_id":117675227,"content_license":"CC BY-SA 4.0","body":"@C.Binair Primarily it&#39;s runtime, i.e. processor predicts branches while executing the code. The processor also remembers previous results and use that to predict next jump. However, compiler can provide some initial hints for branch prediction while compiling - search for &quot;likely&quot; and &quot;unlikely&quot; attributes. So you could say the answer is kinda both, but runtime is when it actually happens."}],"tags":[],"owner":{"badge_counts":{"bronze":321,"silver":320,"gold":43},"reputation":434388,"user_id":922184,"user_type":"registered","profile_image":"https://i.stack.imgur.com/h7WDB.jpg?s=128&g=1","display_name":"Mysticial","link":"https://stackoverflow.com/users/922184/mysticial"},"last_editor":{"badge_counts":{"bronze":103,"silver":60,"gold":6},"reputation":41420,"user_id":3204551,"user_type":"registered","accept_rate":75,"profile_image":"https://www.gravatar.com/avatar/91bb06155f79d40ffecdf124deecb001?s=128&d=identicon&r=PG&f=1","display_name":"Deduplicator","link":"https://stackoverflow.com/users/3204551/deduplicator"},"awarded_bounty_amount":1700,"comment_count":12,"up_vote_count":32924,"is_accepted":true,"score":32895,"last_activity_date":1610292952,"last_edit_date":1610292952,"creation_date":1340805402,"answer_id":11227902,"question_id":11227809,"content_license":"CC BY-SA 4.0","body":"<p><strong>You are a victim of <a href=\"//en.wikipedia.org/wiki/Branch_predictor\" rel=\"noreferrer\">branch prediction</a> fail.</strong></p>\n<hr />\n<h2>What is Branch Prediction?</h2>\n<p>Consider a railroad junction:</p>\n<p><a href=\"//commons.wikimedia.org/wiki/File:Entroncamento_do_Transpraia.JPG\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/muxnt.jpg\" alt=\"Image showing a railroad junction\" /></a>\n<sub><a href=\"//commons.wikimedia.org/wiki/File:Entroncamento_do_Transpraia.JPG\" rel=\"noreferrer\">Image</a> by Mecanismo, via Wikimedia Commons. Used under the <a href=\"//creativecommons.org/licenses/by-sa/3.0/deed.en\" rel=\"noreferrer\">CC-By-SA 3.0</a> license.</sub></p>\n<p>Now for the sake of argument, suppose this is back in the 1800s - before long distance or radio communication.</p>\n<p>You are the operator of a junction and you hear a train coming. You have no idea which way it is supposed to go. You stop the train to ask the driver which direction they want. And then you set the switch appropriately.</p>\n<p><em>Trains are heavy and have a lot of inertia. So they take forever to start up and slow down.</em></p>\n<p>Is there a better way? You guess which direction the train will go!</p>\n<ul>\n<li>If you guessed right, it continues on.</li>\n<li>If you guessed wrong, the captain will stop, back up, and yell at you to flip the switch. Then it can restart down the other path.</li>\n</ul>\n<p><strong>If you guess right every time</strong>, the train will never have to stop.<br />\n<strong>If you guess wrong too often</strong>, the train will spend a lot of time stopping, backing up, and restarting.</p>\n<hr />\n<p><strong>Consider an if-statement:</strong> At the processor level, it is a branch instruction:</p>\n<p><img src=\"https://i.stack.imgur.com/pyfwC.png\" alt=\"Screenshot of compiled code containing an if statement\" /></p>\n<p>You are a processor and you see a branch. You have no idea which way it will go. What do you do? You halt execution and wait until the previous instructions are complete. Then you continue down the correct path.</p>\n<p><em>Modern processors are complicated and have long pipelines. So they take forever to &quot;warm up&quot; and &quot;slow down&quot;.</em></p>\n<p>Is there a better way? You guess which direction the branch will go!</p>\n<ul>\n<li>If you guessed right, you continue executing.</li>\n<li>If you guessed wrong, you need to flush the pipeline and roll back to the branch. Then you can restart down the other path.</li>\n</ul>\n<p><strong>If you guess right every time</strong>, the execution will never have to stop.<br />\n<strong>If you guess wrong too often</strong>, you spend a lot of time stalling, rolling back, and restarting.</p>\n<hr />\n<p>This is branch prediction. I admit it's not the best analogy since the train could just signal the direction with a flag. But in computers, the processor doesn't know which direction a branch will go until the last moment.</p>\n<p>So how would you strategically guess to minimize the number of times that the train must back up and go down the other path? You look at the past history! If the train goes left 99% of the time, then you guess left. If it alternates, then you alternate your guesses. If it goes one way every three times, you guess the same...</p>\n<p><em><strong>In other words, you try to identify a pattern and follow it.</strong></em> This is more or less how branch predictors work.</p>\n<p>Most applications have well-behaved branches. So modern branch predictors will typically achieve &gt;90% hit rates. But when faced with unpredictable branches with no recognizable patterns, branch predictors are virtually useless.</p>\n<p>Further reading: <a href=\"//en.wikipedia.org/wiki/Branch_predictor\" rel=\"noreferrer\">&quot;Branch predictor&quot; article on Wikipedia</a>.</p>\n<hr />\n<h2>As hinted from above, the culprit is this if-statement:</h2>\n<pre><code>if (data[c] &gt;= 128)\n    sum += data[c];\n</code></pre>\n<p>Notice that the data is evenly distributed between 0 and 255. When the data is sorted, roughly the first half of the iterations will not enter the if-statement. After that, they will all enter the if-statement.</p>\n<p>This is very friendly to the branch predictor since the branch consecutively goes the same direction many times. Even a simple saturating counter will correctly predict the branch except for the few iterations after it switches direction.</p>\n<p><strong>Quick visualization:</strong></p>\n<pre class=\"lang-none prettyprint-override\"><code>T = branch taken\nN = branch not taken\n\ndata[] = 0, 1, 2, 3, 4, ... 126, 127, 128, 129, 130, ... 250, 251, 252, ...\nbranch = N  N  N  N  N  ...   N    N    T    T    T  ...   T    T    T  ...\n\n       = NNNNNNNNNNNN ... NNNNNNNTTTTTTTTT ... TTTTTTTTTT  (easy to predict)\n</code></pre>\n<p>However, when the data is completely random, the branch predictor is rendered useless, because it can't predict random data. Thus there will probably be around 50% misprediction (no better than random guessing).</p>\n<pre class=\"lang-none prettyprint-override\"><code>data[] = 226, 185, 125, 158, 198, 144, 217, 79, 202, 118,  14, 150, 177, 182, ...\nbranch =   T,   T,   N,   T,   T,   T,   T,  N,   T,   N,   N,   T,   T,   T  ...\n\n       = TTNTTTTNTNNTTT ...   (completely random - impossible to predict)\n</code></pre>\n<hr />\n<p><strong>So what can be done?</strong></p>\n<p>If the compiler isn't able to optimize the branch into a conditional move, you can try some hacks if you are willing to sacrifice readability for performance.</p>\n<p>Replace:</p>\n<pre><code>if (data[c] &gt;= 128)\n    sum += data[c];\n</code></pre>\n<p>with:</p>\n<pre><code>int t = (data[c] - 128) &gt;&gt; 31;\nsum += ~t &amp; data[c];\n</code></pre>\n<p>This eliminates the branch and replaces it with some bitwise operations.</p>\n<p><sub>(Note that this hack is not strictly equivalent to the original if-statement. But in this case, it's valid for all the input values of <code>data[]</code>.)</sub></p>\n<p><strong>Benchmarks: Core i7 920 @ 3.5 GHz</strong></p>\n<p>C++ - Visual Studio 2010 - x64 Release</p>\n<div class=\"s-table-container\">\n<table class=\"s-table\">\n<thead>\n<tr>\n<th>Scenario</th>\n<th>Time (seconds)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Branching - Random data</td>\n<td>11.777</td>\n</tr>\n<tr>\n<td>Branching - Sorted data</td>\n<td>2.352</td>\n</tr>\n<tr>\n<td>Branchless - Random data</td>\n<td>2.564</td>\n</tr>\n<tr>\n<td>Branchless - Sorted data</td>\n<td>2.587</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>Java - NetBeans 7.1.1 JDK 7 - x64</p>\n<div class=\"s-table-container\">\n<table class=\"s-table\">\n<thead>\n<tr>\n<th>Scenario</th>\n<th>Time (seconds)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Branching - Random data</td>\n<td>10.93293813</td>\n</tr>\n<tr>\n<td>Branching - Sorted data</td>\n<td>5.643797077</td>\n</tr>\n<tr>\n<td>Branchless - Random data</td>\n<td>3.113581453</td>\n</tr>\n<tr>\n<td>Branchless - Sorted data</td>\n<td>3.186068823</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>Observations:</p>\n<ul>\n<li><strong>With the Branch:</strong> There is a huge difference between the sorted and unsorted data.</li>\n<li><strong>With the Hack:</strong> There is no difference between sorted and unsorted data.</li>\n<li>In the C++ case, the hack is actually a tad slower than with the branch when the data is sorted.</li>\n</ul>\n<p>A general rule of thumb is to avoid data-dependent branching in critical loops (such as in this example).</p>\n<hr />\n<p><strong>Update:</strong></p>\n<ul>\n<li><p>GCC 4.6.1 with <code>-O3</code> or <code>-ftree-vectorize</code> on x64 is able to generate a conditional move. So there is no difference between the sorted and unsorted data - both are fast.</p>\n<p>(Or somewhat fast: for the already-sorted case, <code>cmov</code> can be slower especially if GCC puts it on the critical path instead of just <code>add</code>, especially on Intel before Broadwell where <code>cmov</code> has 2 cycle latency: <a href=\"https://stackoverflow.com/questions/28875325/gcc-optimization-flag-o3-makes-code-slower-than-o2\">gcc optimization flag -O3 makes code slower than -O2</a>)</p>\n</li>\n<li><p>VC++ 2010 is unable to generate conditional moves for this branch even under <code>/Ox</code>.</p>\n</li>\n<li><p><a href=\"//en.wikipedia.org/wiki/Intel_C++_Compiler\" rel=\"noreferrer\">Intel C++ Compiler</a> (ICC) 11 does something miraculous. It <a href=\"//en.wikipedia.org/wiki/Loop_interchange\" rel=\"noreferrer\">interchanges the two loops</a>, thereby hoisting the unpredictable branch to the outer loop. So not only is it immune to the mispredictions, it is also twice as fast as whatever VC++ and GCC can generate! In other words, ICC took advantage of the test-loop to defeat the benchmark...</p>\n</li>\n<li><p>If you give the Intel compiler the branchless code, it just out-right vectorizes it... and is just as fast as with the branch (with the loop interchange).</p>\n</li>\n</ul>\n<p>This goes to show that even mature modern compilers can vary wildly in their ability to optimize code...</p>\n"},{"comments":[{"owner":{"badge_counts":{"bronze":21,"silver":4,"gold":0},"reputation":378,"user_id":3924108,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/7b7612263f0c62d716c6dee0fe7ecb76?s=128&d=identicon&r=PG","display_name":"fernal73","link":"https://stackoverflow.com/users/3924108/fernal73"},"edited":false,"score":0,"creation_date":1606968554,"post_id":11237235,"comment_id":115126222,"content_license":"CC BY-SA 4.0","body":"This doesn&#39;t work for Java."},{"owner":{"badge_counts":{"bronze":21,"silver":4,"gold":0},"reputation":378,"user_id":3924108,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/7b7612263f0c62d716c6dee0fe7ecb76?s=128&d=identicon&r=PG","display_name":"fernal73","link":"https://stackoverflow.com/users/3924108/fernal73"},"edited":false,"score":0,"creation_date":1606973524,"post_id":11237235,"comment_id":115127186,"content_license":"CC BY-SA 4.0","body":"<a href=\"https://stackoverflow.com/questions/9745389/is-the-ternary-operator-faster-than-an-if-condition-in-java\" title=\"is the ternary operator faster than an if condition in java\">stackoverflow.com/questions/9745389/&hellip;</a>"}],"tags":[],"owner":{"badge_counts":{"bronze":79,"silver":49,"gold":7},"reputation":41683,"user_id":866732,"user_type":"registered","accept_rate":88,"profile_image":"https://www.gravatar.com/avatar/f09f0253204000d6083ed1de21afc6fd?s=128&d=identicon&r=PG","display_name":"WiSaGaN","link":"https://stackoverflow.com/users/866732/wisagan"},"last_editor":{"badge_counts":{"bronze":103,"silver":60,"gold":6},"reputation":41420,"user_id":3204551,"user_type":"registered","accept_rate":75,"profile_image":"https://www.gravatar.com/avatar/91bb06155f79d40ffecdf124deecb001?s=128&d=identicon&r=PG&f=1","display_name":"Deduplicator","link":"https://stackoverflow.com/users/3204551/deduplicator"},"awarded_bounty_amount":150,"comment_count":2,"up_vote_count":3475,"is_accepted":false,"score":3461,"last_activity_date":1610299340,"last_edit_date":1610299340,"creation_date":1340849643,"answer_id":11237235,"question_id":11227809,"content_license":"CC BY-SA 4.0","body":"<p>The reason why performance improves drastically when the data is sorted is that the branch prediction penalty is removed, as explained beautifully in <a href=\"//stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array/11227902#11227902\">Mysticial's answer</a>.</p>\n<p>Now, if we look at the code</p>\n<pre><code>if (data[c] &gt;= 128)\n    sum += data[c];\n</code></pre>\n<p>we can find that the meaning of this particular <code>if... else...</code> branch is to add something when a condition is satisfied. This type of branch can be easily transformed into a <strong>conditional move</strong> statement, which would be compiled into a conditional move instruction: <code>cmovl</code>, in an <code>x86</code> system. The branch and thus the potential branch prediction penalty is removed.</p>\n<p>In <code>C</code>, thus <code>C++</code>, the statement, which would compile directly (without any optimization) into the conditional move instruction in <code>x86</code>, is the ternary operator <code>... ? ... : ...</code>. So we rewrite the above statement into an equivalent one:</p>\n<pre><code>sum += data[c] &gt;=128 ? data[c] : 0;\n</code></pre>\n<p>While maintaining readability, we can check the speedup factor.</p>\n<p>On an Intel <a href=\"//en.wikipedia.org/wiki/Intel_Core#Core_i7\" rel=\"noreferrer\">Core i7</a>-2600K @ 3.4 GHz and Visual Studio 2010 Release Mode, the benchmark is:</p>\n<p><strong>x86</strong></p>\n<div class=\"s-table-container\">\n<table class=\"s-table\">\n<thead>\n<tr>\n<th>Scenario</th>\n<th>Time (seconds)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Branching - Random data</td>\n<td>8.885</td>\n</tr>\n<tr>\n<td>Branching - Sorted data</td>\n<td>1.528</td>\n</tr>\n<tr>\n<td>Branchless - Random data</td>\n<td>3.716</td>\n</tr>\n<tr>\n<td>Branchless - Sorted data</td>\n<td>3.71</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>x64</strong></p>\n<div class=\"s-table-container\">\n<table class=\"s-table\">\n<thead>\n<tr>\n<th>Scenario</th>\n<th>Time (seconds)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Branching - Random data</td>\n<td>11.302</td>\n</tr>\n<tr>\n<td>Branching - Sorted data</td>\n<td>1.830</td>\n</tr>\n<tr>\n<td>Branchless - Random data</td>\n<td>2.736</td>\n</tr>\n<tr>\n<td>Branchless - Sorted data</td>\n<td>2.737</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>The result is robust in multiple tests. We get a great speedup when the branch result is unpredictable, but we suffer a little bit when it is predictable. In fact, when using a conditional move, the performance is the same regardless of the data pattern.</p>\n<p>Now let's look more closely by investigating the <code>x86</code> assembly they generate. For simplicity, we use two functions <code>max1</code> and <code>max2</code>.</p>\n<p><code>max1</code> uses the conditional branch <code>if... else ...</code>:</p>\n<pre><code>int max1(int a, int b) {\n    if (a &gt; b)\n        return a;\n    else\n        return b;\n}\n</code></pre>\n<p><code>max2</code> uses the ternary operator <code>... ? ... : ...</code>:</p>\n<pre><code>int max2(int a, int b) {\n    return a &gt; b ? a : b;\n}\n</code></pre>\n<p>On a x86-64 machine, <code>GCC -S</code> generates the assembly below.</p>\n<pre><code>:max1\n    movl    %edi, -4(%rbp)\n    movl    %esi, -8(%rbp)\n    movl    -4(%rbp), %eax\n    cmpl    -8(%rbp), %eax\n    jle     .L2\n    movl    -4(%rbp), %eax\n    movl    %eax, -12(%rbp)\n    jmp     .L4\n.L2:\n    movl    -8(%rbp), %eax\n    movl    %eax, -12(%rbp)\n.L4:\n    movl    -12(%rbp), %eax\n    leave\n    ret\n\n:max2\n    movl    %edi, -4(%rbp)\n    movl    %esi, -8(%rbp)\n    movl    -4(%rbp), %eax\n    cmpl    %eax, -8(%rbp)\n    cmovge  -8(%rbp), %eax\n    leave\n    ret\n</code></pre>\n<p><code>max2</code> uses much less code due to the usage of instruction <code>cmovge</code>. But the real gain is that <code>max2</code> does not involve branch jumps, <code>jmp</code>, which would have a significant performance penalty if the predicted result is not right.</p>\n<p>So why does a conditional move perform better?</p>\n<p>In a typical <code>x86</code> processor, the execution of an instruction is divided into several stages. Roughly, we have different hardware to deal with different stages. So we do not have to wait for one instruction to finish to start a new one. This is called <strong><a href=\"//en.wikipedia.org/wiki/Pipeline_(computing)\" rel=\"noreferrer\">pipelining</a></strong>.</p>\n<p>In a branch case, the following instruction is determined by the preceding one, so we cannot do pipelining. We have to either wait or predict.</p>\n<p>In a conditional move case, the execution conditional move instruction is divided into several stages, but the earlier stages like <code>Fetch</code> and <code>Decode</code> do not depend on the result of the previous instruction; only latter stages need the result. Thus, we wait a fraction of one instruction's execution time. This is why the conditional move version is slower than the branch when the prediction is easy.</p>\n<p>The book <em><a href=\"https://rads.stackoverflow.com/amzn/click/com/0136108040\" rel=\"noreferrer\" rel=\"nofollow noreferrer\">Computer Systems: A Programmer's Perspective, second edition</a></em> explains this in detail. You can check Section 3.6.6 for <em>Conditional Move Instructions</em>, entire Chapter 4 for <em>Processor Architecture</em>, and Section 5.11.2 for special treatment for <em>Branch Prediction and Misprediction Penalties</em>.</p>\n<p>Sometimes, some modern compilers can optimize our code to assembly with better performance, sometimes some compilers can't (the code in question is using Visual Studio's native compiler). Knowing the performance difference between a branch and a conditional move when unpredictable can help us write code with better performance when the scenario gets so complex that the compiler can not optimize them automatically.</p>\n"},{"tags":[],"owner":{"badge_counts":{"bronze":90,"silver":51,"gold":8},"reputation":29421,"user_id":863980,"user_type":"registered","accept_rate":83,"profile_image":"https://www.gravatar.com/avatar/ea08c9063ae1de86e8d576fb569d513a?s=128&d=identicon&r=PG","display_name":"vulcan raven","link":"https://stackoverflow.com/users/863980/vulcan-raven"},"last_editor":{"badge_counts":{"bronze":123,"silver":94,"gold":21},"reputation":27825,"user_id":63550,"user_type":"registered","accept_rate":78,"profile_image":"https://i.stack.imgur.com/RIZKi.png?s=128&g=1","display_name":"Peter Mortensen","link":"https://stackoverflow.com/users/63550/peter-mortensen"},"comment_count":0,"up_vote_count":2411,"is_accepted":false,"score":2388,"last_activity_date":1558961493,"last_edit_date":1558961493,"creation_date":1341282330,"answer_id":11303693,"question_id":11227809,"content_license":"CC BY-SA 4.0","body":"<p>If you are curious about even more optimizations that can be done to this code, consider this:</p>\n\n<p>Starting with the original loop:</p>\n\n<pre><code>for (unsigned i = 0; i &lt; 100000; ++i)\n{\n    for (unsigned j = 0; j &lt; arraySize; ++j)\n    {\n        if (data[j] &gt;= 128)\n            sum += data[j];\n    }\n}\n</code></pre>\n\n<p>With loop interchange, we can safely change this loop to:</p>\n\n<pre><code>for (unsigned j = 0; j &lt; arraySize; ++j)\n{\n    for (unsigned i = 0; i &lt; 100000; ++i)\n    {\n        if (data[j] &gt;= 128)\n            sum += data[j];\n    }\n}\n</code></pre>\n\n<p>Then, you can see that the <code>if</code> conditional is constant throughout the execution of the <code>i</code> loop, so you can hoist the <code>if</code> out:</p>\n\n<pre><code>for (unsigned j = 0; j &lt; arraySize; ++j)\n{\n    if (data[j] &gt;= 128)\n    {\n        for (unsigned i = 0; i &lt; 100000; ++i)\n        {\n            sum += data[j];\n        }\n    }\n}\n</code></pre>\n\n<p>Then, you see that the inner loop can be collapsed into one single expression, assuming the floating point model allows it (<code>/fp:fast</code> is thrown, for example)</p>\n\n<pre><code>for (unsigned j = 0; j &lt; arraySize; ++j)\n{\n    if (data[j] &gt;= 128)\n    {\n        sum += data[j] * 100000;\n    }\n}\n</code></pre>\n\n<p>That one is 100,000 times faster than before.</p>\n"},{"comments":[{"owner":{"badge_counts":{"bronze":13,"silver":8,"gold":0},"reputation":1140,"user_id":2383730,"user_type":"registered","accept_rate":83,"profile_image":"https://i.stack.imgur.com/giP28.jpg?s=128&g=1","display_name":"TallBrian","link":"https://stackoverflow.com/users/2383730/tallbrian"},"edited":false,"score":86,"creation_date":1386561609,"post_id":12853037,"comment_id":30576818,"content_license":"CC BY-SA 3.0","body":"This is scary, in the unsorted list, there should be 50% chance of hitting the add.  Somehow the branch prediction only has a 25% miss rate, how can it do better than 50% miss?"},{"owner":{"badge_counts":{"bronze":431,"silver":282,"gold":34},"reputation":215017,"user_id":134633,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/dc6be45ddcfd038ba5e1e5fca319c7fa?s=128&d=identicon&r=PG","display_name":"caf","link":"https://stackoverflow.com/users/134633/caf"},"reply_to_user":{"badge_counts":{"bronze":13,"silver":8,"gold":0},"reputation":1140,"user_id":2383730,"user_type":"registered","accept_rate":83,"profile_image":"https://i.stack.imgur.com/giP28.jpg?s=128&g=1","display_name":"TallBrian","link":"https://stackoverflow.com/users/2383730/tallbrian"},"edited":false,"score":143,"creation_date":1386563365,"post_id":12853037,"comment_id":30577316,"content_license":"CC BY-SA 3.0","body":"@tall.b.lo: The 25% is of all branches - there are <i>two</i> branches in the loop, one for <code>data[c] &gt;= 128</code> (which has a 50% miss rate as you suggest) and one for the loop condition <code>c &lt; arraySize</code> which has ~0% miss rate."}],"tags":[],"owner":{"badge_counts":{"bronze":431,"silver":282,"gold":34},"reputation":215017,"user_id":134633,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/dc6be45ddcfd038ba5e1e5fca319c7fa?s=128&d=identicon&r=PG","display_name":"caf","link":"https://stackoverflow.com/users/134633/caf"},"last_editor":{"badge_counts":{"bronze":123,"silver":94,"gold":21},"reputation":27825,"user_id":63550,"user_type":"registered","accept_rate":78,"profile_image":"https://i.stack.imgur.com/RIZKi.png?s=128&g=1","display_name":"Peter Mortensen","link":"https://stackoverflow.com/users/63550/peter-mortensen"},"comment_count":2,"up_vote_count":1970,"is_accepted":false,"score":1967,"last_activity_date":1350588021,"last_edit_date":1350588021,"creation_date":1350021213,"answer_id":12853037,"question_id":11227809,"content_license":"CC BY-SA 3.0","body":"<p>No doubt some of us would be interested in ways of identifying code that is problematic for the CPU's branch-predictor. The Valgrind tool <code>cachegrind</code> has a branch-predictor simulator, enabled by using the <code>--branch-sim=yes</code> flag. Running it over the examples in this question, with the number of outer loops reduced to 10000 and compiled with <code>g++</code>, gives these results:</p>\n\n<p><strong>Sorted:</strong></p>\n\n<pre><code>==32551== Branches:        656,645,130  (  656,609,208 cond +    35,922 ind)\n==32551== Mispredicts:         169,556  (      169,095 cond +       461 ind)\n==32551== Mispred rate:            0.0% (          0.0%     +       1.2%   )\n</code></pre>\n\n<p><strong>Unsorted:</strong></p>\n\n<pre><code>==32555== Branches:        655,996,082  (  655,960,160 cond +  35,922 ind)\n==32555== Mispredicts:     164,073,152  (  164,072,692 cond +     460 ind)\n==32555== Mispred rate:           25.0% (         25.0%     +     1.2%   )\n</code></pre>\n\n<p>Drilling down into the line-by-line output produced by <code>cg_annotate</code> we see for the loop in question:</p>\n\n<p><strong>Sorted:</strong></p>\n\n<pre><code>          Bc    Bcm Bi Bim\n      10,001      4  0   0      for (unsigned i = 0; i &lt; 10000; ++i)\n           .      .  .   .      {\n           .      .  .   .          // primary loop\n 327,690,000 10,016  0   0          for (unsigned c = 0; c &lt; arraySize; ++c)\n           .      .  .   .          {\n 327,680,000 10,006  0   0              if (data[c] &gt;= 128)\n           0      0  0   0                  sum += data[c];\n           .      .  .   .          }\n           .      .  .   .      }\n</code></pre>\n\n<p><strong>Unsorted:</strong></p>\n\n<pre><code>          Bc         Bcm Bi Bim\n      10,001           4  0   0      for (unsigned i = 0; i &lt; 10000; ++i)\n           .           .  .   .      {\n           .           .  .   .          // primary loop\n 327,690,000      10,038  0   0          for (unsigned c = 0; c &lt; arraySize; ++c)\n           .           .  .   .          {\n 327,680,000 164,050,007  0   0              if (data[c] &gt;= 128)\n           0           0  0   0                  sum += data[c];\n           .           .  .   .          }\n           .           .  .   .      }\n</code></pre>\n\n<p>This lets you easily identify the problematic line - in the unsorted version the <code>if (data[c] &gt;= 128)</code> line is causing 164,050,007 mispredicted conditional branches (<code>Bcm</code>) under cachegrind's branch-predictor model, whereas it's only causing 10,006 in the sorted version.</p>\n\n<hr>\n\n<p>Alternatively, on Linux you can use the performance counters subsystem to accomplish the same task, but with native performance using CPU counters.</p>\n\n<pre><code>perf stat ./sumtest_sorted\n</code></pre>\n\n<p><strong>Sorted:</strong></p>\n\n<pre><code> Performance counter stats for './sumtest_sorted':\n\n  11808.095776 task-clock                #    0.998 CPUs utilized          \n         1,062 context-switches          #    0.090 K/sec                  \n            14 CPU-migrations            #    0.001 K/sec                  \n           337 page-faults               #    0.029 K/sec                  \n26,487,882,764 cycles                    #    2.243 GHz                    \n41,025,654,322 instructions              #    1.55  insns per cycle        \n 6,558,871,379 branches                  #  555.455 M/sec                  \n       567,204 branch-misses             #    0.01% of all branches        \n\n  11.827228330 seconds time elapsed\n</code></pre>\n\n<p><strong>Unsorted:</strong></p>\n\n<pre><code> Performance counter stats for './sumtest_unsorted':\n\n  28877.954344 task-clock                #    0.998 CPUs utilized          \n         2,584 context-switches          #    0.089 K/sec                  \n            18 CPU-migrations            #    0.001 K/sec                  \n           335 page-faults               #    0.012 K/sec                  \n65,076,127,595 cycles                    #    2.253 GHz                    \n41,032,528,741 instructions              #    0.63  insns per cycle        \n 6,560,579,013 branches                  #  227.183 M/sec                  \n 1,646,394,749 branch-misses             #   25.10% of all branches        \n\n  28.935500947 seconds time elapsed\n</code></pre>\n\n<p>It can also do source code annotation with dissassembly.</p>\n\n<pre><code>perf record -e branch-misses ./sumtest_unsorted\nperf annotate -d sumtest_unsorted\n</code></pre>\n\n\n\n<pre><code> Percent |      Source code &amp; Disassembly of sumtest_unsorted\n------------------------------------------------\n...\n         :                      sum += data[c];\n    0.00 :        400a1a:       mov    -0x14(%rbp),%eax\n   39.97 :        400a1d:       mov    %eax,%eax\n    5.31 :        400a1f:       mov    -0x20040(%rbp,%rax,4),%eax\n    4.60 :        400a26:       cltq   \n    0.00 :        400a28:       add    %rax,-0x30(%rbp)\n...\n</code></pre>\n\n<p>See <a href=\"https://perf.wiki.kernel.org/index.php/Tutorial\" rel=\"noreferrer\">the performance tutorial</a> for more details.</p>\n"},{"comments":[{"owner":{"badge_counts":{"bronze":103,"silver":49,"gold":7},"reputation":6915,"user_id":274579,"user_type":"registered","accept_rate":61,"profile_image":"https://www.gravatar.com/avatar/745415fffcdea46caf03c90534a4c7fa?s=128&d=identicon&r=PG","display_name":"ysap","link":"https://stackoverflow.com/users/274579/ysap"},"edited":false,"score":8,"creation_date":1368820380,"post_id":14092288,"comment_id":23890444,"content_license":"CC BY-SA 3.0","body":"Just for the sake of completeness, this is probably not how you&#39;d implement that in Matlab. I bet it&#39;d be much faster if done after vectorizing the problem."},{"owner":{"badge_counts":{"bronze":57,"silver":40,"gold":10},"reputation":4400,"user_id":1020149,"user_type":"registered","accept_rate":21,"profile_image":"https://www.gravatar.com/avatar/911f564e95671ac04ec1841524d76171?s=128&d=identicon&r=PG","display_name":"Shan","link":"https://stackoverflow.com/users/1020149/shan"},"reply_to_user":{"badge_counts":{"bronze":103,"silver":49,"gold":7},"reputation":6915,"user_id":274579,"user_type":"registered","accept_rate":61,"profile_image":"https://www.gravatar.com/avatar/745415fffcdea46caf03c90534a4c7fa?s=128&d=identicon&r=PG","display_name":"ysap","link":"https://stackoverflow.com/users/274579/ysap"},"edited":false,"score":1,"creation_date":1368834624,"post_id":14092288,"comment_id":23895018,"content_license":"CC BY-SA 3.0","body":"Matlab does automatic parallelization / vectorization in many situations but the issue here is to check the effect of branch prediction. Matlab is not immune in anyway!"},{"owner":{"badge_counts":{"bronze":321,"silver":171,"gold":28},"reputation":68889,"user_id":53897,"user_type":"registered","accept_rate":56,"profile_image":"https://www.gravatar.com/avatar/2e71c1745ebc5401c8c8dfbf7c9a5d30?s=128&d=identicon&r=PG","display_name":"Thorbj&#248;rn Ravn Andersen","link":"https://stackoverflow.com/users/53897/thorbj%c3%b8rn-ravn-andersen"},"edited":false,"score":1,"creation_date":1377362072,"post_id":14092288,"comment_id":27061346,"content_license":"CC BY-SA 3.0","body":"Does matlab use native numbers or a mat lab specific implementation (infinite amount of digits or so?)"}],"tags":[],"owner":{"badge_counts":{"bronze":57,"silver":40,"gold":10},"reputation":4400,"user_id":1020149,"user_type":"registered","accept_rate":21,"profile_image":"https://www.gravatar.com/avatar/911f564e95671ac04ec1841524d76171?s=128&d=identicon&r=PG","display_name":"Shan","link":"https://stackoverflow.com/users/1020149/shan"},"last_editor":{"badge_counts":{"bronze":123,"silver":94,"gold":21},"reputation":27825,"user_id":63550,"user_type":"registered","accept_rate":78,"profile_image":"https://i.stack.imgur.com/RIZKi.png?s=128&g=1","display_name":"Peter Mortensen","link":"https://stackoverflow.com/users/63550/peter-mortensen"},"comment_count":3,"up_vote_count":147,"is_accepted":false,"score":146,"last_activity_date":1521204334,"last_edit_date":1521204334,"creation_date":1356884206,"answer_id":14092288,"question_id":11227809,"content_license":"CC BY-SA 3.0","body":"<p>I tried the same code with MATLAB 2011b with my MacBook Pro (Intel i7, 64 bit, 2.4 GHz) for the following MATLAB code:</p>\n\n<pre><code>% Processing time with Sorted data vs unsorted data\n%==========================================================================\n% Generate data\narraySize = 32768\nsum = 0;\n% Generate random integer data from range 0 to 255\ndata = randi(256, arraySize, 1);\n\n\n%Sort the data\ndata1= sort(data); % data1= data  when no sorting done\n\n\n%Start a stopwatch timer to measure the execution time\ntic;\n\nfor i=1:100000\n\n    for j=1:arraySize\n\n        if data1(j)&gt;=128\n            sum=sum + data1(j);\n        end\n    end\nend\n\ntoc;\n\nExeTimeWithSorting = toc - tic;\n</code></pre>\n\n<p>The results for the above MATLAB code are as follows:</p>\n\n<pre><code>  a: Elapsed time (without sorting) = 3479.880861 seconds.\n  b: Elapsed time (with sorting ) = 2377.873098 seconds.\n</code></pre>\n\n<p>The results of the C code as in @GManNickG I get:</p>\n\n<pre><code>  a: Elapsed time (without sorting) = 19.8761 sec.\n  b: Elapsed time (with sorting ) = 7.37778 sec.\n</code></pre>\n\n<p>Based on this, it looks MATLAB is almost <em>175 times</em> slower than the C implementation without sorting and <em>350 times</em> slower with sorting. In other words, the effect (of branch prediction) is <em>1.46x</em> for MATLAB implementation and <em>2.7x</em> for the C implementation.</p>\n"},{"comments":[{"owner":{"badge_counts":{"bronze":35,"silver":20,"gold":0},"reputation":2259,"user_id":4037019,"user_type":"registered","accept_rate":100,"profile_image":"https://i.stack.imgur.com/nveNe.jpg?s=128&g=1","display_name":"cst1992","link":"https://stackoverflow.com/users/4037019/cst1992"},"reply_to_user":{"badge_counts":{"bronze":146,"silver":89,"gold":15},"reputation":55646,"user_id":845092,"user_type":"registered","accept_rate":93,"profile_image":"https://www.gravatar.com/avatar/50ccdbac5f0f9ff683e4b30a248189bf?s=128&d=identicon&r=PG","display_name":"Mooing Duck","link":"https://stackoverflow.com/users/845092/mooing-duck"},"edited":false,"score":32,"creation_date":1459169931,"post_id":14889969,"comment_id":60153643,"content_license":"CC BY-SA 3.0","body":"@MooingDuck &#39;Cause it won&#39;t make a difference - that value can be anything, but it still will be in the bounds of these thresholds. So why show a random value when you already know the limits? Although I agree that you could show one for the sake of completeness, and &#39;just for the heck of it&#39;."},{"owner":{"badge_counts":{"bronze":146,"silver":89,"gold":15},"reputation":55646,"user_id":845092,"user_type":"registered","accept_rate":93,"profile_image":"https://www.gravatar.com/avatar/50ccdbac5f0f9ff683e4b30a248189bf?s=128&d=identicon&r=PG","display_name":"Mooing Duck","link":"https://stackoverflow.com/users/845092/mooing-duck"},"reply_to_user":{"badge_counts":{"bronze":35,"silver":20,"gold":0},"reputation":2259,"user_id":4037019,"user_type":"registered","accept_rate":100,"profile_image":"https://i.stack.imgur.com/nveNe.jpg?s=128&g=1","display_name":"cst1992","link":"https://stackoverflow.com/users/4037019/cst1992"},"edited":false,"score":33,"creation_date":1459189636,"post_id":14889969,"comment_id":60164274,"content_license":"CC BY-SA 3.0","body":"@cst1992: Right now his slowest timing is TTFFTTFFTTFF, which seems, to my human eye, quite predictable. Random is inherently unpredictable, so it&#39;s entirely possible it would be slower still, and thus outside the limits shown here.  OTOH, it could be that TTFFTTFF perfectly hits the pathological case.  Can&#39;t tell, since he didn&#39;t show the timings for random."},{"owner":{"badge_counts":{"bronze":112,"silver":85,"gold":18},"reputation":66604,"user_id":166949,"user_type":"registered","accept_rate":90,"profile_image":"https://i.stack.imgur.com/tIFie.png?s=128&g=1","display_name":"steveha","link":"https://stackoverflow.com/users/166949/steveha"},"reply_to_user":{"badge_counts":{"bronze":146,"silver":89,"gold":15},"reputation":55646,"user_id":845092,"user_type":"registered","accept_rate":93,"profile_image":"https://www.gravatar.com/avatar/50ccdbac5f0f9ff683e4b30a248189bf?s=128&d=identicon&r=PG","display_name":"Mooing Duck","link":"https://stackoverflow.com/users/845092/mooing-duck"},"edited":false,"score":30,"creation_date":1469048857,"post_id":14889969,"comment_id":64383305,"content_license":"CC BY-SA 3.0","body":"@MooingDuck To a human eye, &quot;TTFFTTFFTTFF&quot; is a predictable sequence, but what we are talking about here is the behavior of the branch predictor built into a CPU.  The branch predictor is not AI-level pattern recognition; it&#39;s very simple.  When you just alternate branches it doesn&#39;t predict well.  In most code, branches go the same way almost all the time; consider a loop that executes a thousand times.  The branch at the end of the loop goes back to the start of the loop 999 times, and then the thousandth time does something different.  A very simple branch predictor works well, usually."},{"owner":{"badge_counts":{"bronze":146,"silver":89,"gold":15},"reputation":55646,"user_id":845092,"user_type":"registered","accept_rate":93,"profile_image":"https://www.gravatar.com/avatar/50ccdbac5f0f9ff683e4b30a248189bf?s=128&d=identicon&r=PG","display_name":"Mooing Duck","link":"https://stackoverflow.com/users/845092/mooing-duck"},"reply_to_user":{"badge_counts":{"bronze":112,"silver":85,"gold":18},"reputation":66604,"user_id":166949,"user_type":"registered","accept_rate":90,"profile_image":"https://i.stack.imgur.com/tIFie.png?s=128&g=1","display_name":"steveha","link":"https://stackoverflow.com/users/166949/steveha"},"edited":false,"score":25,"creation_date":1469049018,"post_id":14889969,"comment_id":64383386,"content_license":"CC BY-SA 3.0","body":"@steveha: I think you&#39;re making assumptions about how the CPU branch predictor works, and I disagree with that methodology. I don&#39;t know how advanced that branch predictor is, but I seem to think it&#39;s far more advanced than you do. You&#39;re probably right, but measurements would definitely be good."},{"owner":{"badge_counts":{"bronze":112,"silver":85,"gold":18},"reputation":66604,"user_id":166949,"user_type":"registered","accept_rate":90,"profile_image":"https://i.stack.imgur.com/tIFie.png?s=128&g=1","display_name":"steveha","link":"https://stackoverflow.com/users/166949/steveha"},"reply_to_user":{"badge_counts":{"bronze":146,"silver":89,"gold":15},"reputation":55646,"user_id":845092,"user_type":"registered","accept_rate":93,"profile_image":"https://www.gravatar.com/avatar/50ccdbac5f0f9ff683e4b30a248189bf?s=128&d=identicon&r=PG","display_name":"Mooing Duck","link":"https://stackoverflow.com/users/845092/mooing-duck"},"edited":false,"score":4,"creation_date":1469504955,"post_id":14889969,"comment_id":64550377,"content_license":"CC BY-SA 3.0","body":"@MooingDuck It is true that I am not an expert in processor design.  But I invite you to read the Wikipedia page about branch predictors.  Not one of the discussed designs could lock on to the pattern TTFFTTFF... and predict correctly.  (Except maybe for the neural net one, with a sufficiently advanced neural net, and I&#39;ll bet you cash money that you don&#39;t own a computing device that has such a branch predictor in its processor.)  <a href=\"https://en.wikipedia.org/wiki/Branch_predictor\" rel=\"nofollow noreferrer\">en.wikipedia.org/wiki/Branch_predictor</a>"},{"owner":{"badge_counts":{"bronze":146,"silver":89,"gold":15},"reputation":55646,"user_id":845092,"user_type":"registered","accept_rate":93,"profile_image":"https://www.gravatar.com/avatar/50ccdbac5f0f9ff683e4b30a248189bf?s=128&d=identicon&r=PG","display_name":"Mooing Duck","link":"https://stackoverflow.com/users/845092/mooing-duck"},"reply_to_user":{"badge_counts":{"bronze":112,"silver":85,"gold":18},"reputation":66604,"user_id":166949,"user_type":"registered","accept_rate":90,"profile_image":"https://i.stack.imgur.com/tIFie.png?s=128&g=1","display_name":"steveha","link":"https://stackoverflow.com/users/166949/steveha"},"edited":false,"score":9,"creation_date":1469507635,"post_id":14889969,"comment_id":64551074,"content_license":"CC BY-SA 3.0","body":"@steveha: The Two-level adaptive predictor could lock onto the TTFFTTFF pattern with no issue whatsoever. &quot;Variants of this prediction method are used in most modern microprocessors&quot;. Local branch prediction and Global branch prediction are based on a two level adaptive predictor, they can as well. &quot;Global branch prediction is used in AMD processors, and in Intel Pentium M, Core, Core 2, and Silvermont-based Atom processors&quot;  Also add Agree predictor, Hybrid predictor, Prediction of indirect jumps, to that list. Loop predictor wont lock on, but hits 75%. That leaves only 2 that can&#39;t lock on"},{"owner":{"badge_counts":{"bronze":9,"silver":0,"gold":0},"reputation":97,"user_id":4509583,"user_type":"registered","profile_image":"https://i.stack.imgur.com/zda9x.jpg?s=128&g=1","display_name":"Warren K","link":"https://stackoverflow.com/users/4509583/warren-k"},"reply_to_user":{"badge_counts":{"bronze":146,"silver":89,"gold":15},"reputation":55646,"user_id":845092,"user_type":"registered","accept_rate":93,"profile_image":"https://www.gravatar.com/avatar/50ccdbac5f0f9ff683e4b30a248189bf?s=128&d=identicon&r=PG","display_name":"Mooing Duck","link":"https://stackoverflow.com/users/845092/mooing-duck"},"edited":false,"score":5,"creation_date":1482532327,"post_id":14889969,"comment_id":69820096,"content_license":"CC BY-SA 3.0","body":"@MooingDuck : The diagram in Surt&#39;s <a href=\"http://stackoverflow.com/a/33070112/4509583\">answer below</a> I think explains why TTFFTTFF is in fact the &quot;pathological case&quot; in Saqlain&#39;s example."}],"tags":[],"owner":{"badge_counts":{"bronze":33,"silver":25,"gold":4},"reputation":15810,"user_id":1012551,"user_type":"registered","accept_rate":92,"profile_image":"https://www.gravatar.com/avatar/22df608584e3ef466f34afef94f134df?s=128&d=identicon&r=PG","display_name":"Saqlain","link":"https://stackoverflow.com/users/1012551/saqlain"},"last_editor":{"badge_counts":{"bronze":42,"silver":24,"gold":3},"reputation":3715,"user_id":4298200,"user_type":"registered","accept_rate":62,"profile_image":"https://lh5.googleusercontent.com/-HcKtiretO2g/AAAAAAAAAAI/AAAAAAAAAH0/IXGAL7MX8sQ/photo.jpg?sz=128","display_name":"Neuron","link":"https://stackoverflow.com/users/4298200/neuron"},"comment_count":7,"up_vote_count":1270,"is_accepted":false,"score":1266,"last_activity_date":1551265112,"last_edit_date":1551265112,"creation_date":1360913056,"answer_id":14889969,"question_id":11227809,"content_license":"CC BY-SA 4.0","body":"<p>As data is distributed between 0 and 255 when the array is sorted, around the first half of the iterations will not enter the <code>if</code>-statement (the <code>if</code> statement is shared below).</p>\n\n<pre><code>if (data[c] &gt;= 128)\n    sum += data[c];\n</code></pre>\n\n<p>The question is: What makes the above statement not execute in certain cases as in case of sorted data? Here comes the \"branch predictor\". A branch predictor is a digital circuit that tries to guess which way a branch (e.g. an <code>if-then-else</code> structure) will go before this is known for sure. The purpose of the branch predictor is to improve the flow in the instruction pipeline. Branch predictors play a critical role in achieving high effective performance!</p>\n\n<p><strong>Let's do some bench marking to understand it better</strong></p>\n\n<p>The performance of an <code>if</code>-statement depends on whether its condition has a predictable pattern. If the condition is always true or always false, the branch prediction logic in the processor will pick up the pattern. On the other hand, if the pattern is unpredictable, the <code>if</code>-statement will be much more expensive.</p>\n\n<p>Let’s measure the performance of this loop with different conditions:</p>\n\n<pre><code>for (int i = 0; i &lt; max; i++)\n    if (condition)\n        sum++;\n</code></pre>\n\n<p>Here are the timings of the loop with different true-false patterns:</p>\n\n<pre><code>Condition                Pattern             Time (ms)\n-------------------------------------------------------\n(i &amp; 0×80000000) == 0    T repeated          322\n\n(i &amp; 0xffffffff) == 0    F repeated          276\n\n(i &amp; 1) == 0             TF alternating      760\n\n(i &amp; 3) == 0             TFFFTFFF…           513\n\n(i &amp; 2) == 0             TTFFTTFF…           1675\n\n(i &amp; 4) == 0             TTTTFFFFTTTTFFFF…   1275\n\n(i &amp; 8) == 0             8T 8F 8T 8F …       752\n\n(i &amp; 16) == 0            16T 16F 16T 16F …   490\n</code></pre>\n\n<p>A “<strong>bad</strong>” true-false pattern can make an <code>if</code>-statement up to six times slower than a “<strong>good</strong>” pattern! Of course, which pattern is good and which is bad depends on the exact instructions generated by the compiler and on the specific processor.</p>\n\n<p>So there is no doubt about the impact of branch prediction on performance!</p>\n"},{"tags":[],"owner":{"badge_counts":{"bronze":72,"silver":52,"gold":3},"reputation":27442,"user_id":1031591,"user_type":"registered","accept_rate":71,"profile_image":"https://i.stack.imgur.com/s3MiH.jpg?s=128&g=1","display_name":"atlaste","link":"https://stackoverflow.com/users/1031591/atlaste"},"last_editor":{"badge_counts":{"bronze":113,"silver":52,"gold":7},"reputation":10184,"user_id":2157640,"user_type":"registered","accept_rate":89,"profile_image":"https://i.stack.imgur.com/aoymS.png?s=128&g=1","display_name":"Palec","link":"https://stackoverflow.com/users/2157640/palec"},"comment_count":0,"up_vote_count":1418,"is_accepted":false,"score":1416,"last_activity_date":1547614041,"last_edit_date":1547614041,"creation_date":1366784788,"answer_id":16184827,"question_id":11227809,"content_license":"CC BY-SA 4.0","body":"<p>I just read up on this question and its answers, and I feel an answer is missing.</p>\n\n<p>A common way to eliminate branch prediction that I've found to work particularly good in managed languages is a table lookup instead of using a branch (although I haven't tested it in this case).</p>\n\n<p>This approach works in general if:</p>\n\n<ol>\n<li>it's a small table and is likely to be cached in the processor, and</li>\n<li>you are running things in a quite tight loop and/or the processor can preload the data.</li>\n</ol>\n\n<p><strong>Background and why</strong></p>\n\n<p>From a processor perspective, your memory is slow. To compensate for the difference in speed, a couple of caches are built into your processor (L1/L2 cache). So imagine that you're doing your nice calculations and figure out that you need a piece of memory. The processor will get its 'load' operation and loads the piece of memory into cache -- and then uses the cache to do the rest of the calculations. Because memory is relatively slow, this 'load' will slow down your program.</p>\n\n<p>Like branch prediction, this was optimized in the Pentium processors: the processor predicts that it needs to load a piece of data and attempts to load that into the cache before the operation actually hits the cache. As we've already seen, branch prediction sometimes goes horribly wrong -- in the worst case scenario you need to go back and actually wait for a memory load, which will take forever (<strong>in other words: failing branch prediction is bad, a memory load after a branch prediction fail is just horrible!</strong>).</p>\n\n<p>Fortunately for us, if the memory access pattern is predictable, the processor will load it in its fast cache and all is well.</p>\n\n<p>The first thing we need to know is what is <em>small</em>? While smaller is generally better, a rule of thumb is to stick to lookup tables that are &lt;= 4096 bytes in size. As an upper limit: if your lookup table is larger than 64K it's probably worth reconsidering.</p>\n\n<p><strong>Constructing a table</strong></p>\n\n<p>So we've figured out that we can create a small table. Next thing to do is get a lookup function in place. Lookup functions are usually small functions that use a couple of basic integer operations (and, or, xor, shift, add, remove and perhaps multiply). You want to have your input translated by the lookup function to some kind of 'unique key' in your table, which then simply gives you the answer of all the work you wanted it to do.</p>\n\n<p>In this case: >= 128 means we can keep the value, &lt; 128 means we get rid of it. The easiest way to do that is by using an 'AND': if we keep it, we AND it with 7FFFFFFF; if we want to get rid of it, we AND it with 0. Notice also that 128 is a power of 2 -- so we can go ahead and make a table of 32768/128 integers and fill it with one zero and a lot of 7FFFFFFFF's.</p>\n\n<p><strong>Managed languages</strong></p>\n\n<p>You might wonder why this works well in managed languages. After all, managed languages check the boundaries of the arrays with a branch to ensure you don't mess up...</p>\n\n<p>Well, not exactly... :-)</p>\n\n<p>There has been quite some work on eliminating this branch for managed languages. For example:</p>\n\n\n\n<pre class=\"lang-cs prettyprint-override\"><code>for (int i = 0; i &lt; array.Length; ++i)\n{\n   // Use array[i]\n}\n</code></pre>\n\n<p>In this case, it's obvious to the compiler that the boundary condition will never be hit. At least the Microsoft JIT compiler (but I expect Java does similar things) will notice this and remove the check altogether. WOW, that means no branch. Similarly, it will deal with other obvious cases.</p>\n\n<p>If you run into trouble with lookups in managed languages -- the key is to add a <code>&amp; 0x[something]FFF</code> to your lookup function to make the boundary check predictable -- and watch it going faster.</p>\n\n<p><strong>The result of this case</strong></p>\n\n<pre class=\"lang-cs prettyprint-override\"><code>// Generate data\nint arraySize = 32768;\nint[] data = new int[arraySize];\n\nRandom random = new Random(0);\nfor (int c = 0; c &lt; arraySize; ++c)\n{\n    data[c] = random.Next(256);\n}\n\n/*To keep the spirit of the code intact, I'll make a separate lookup table\n(I assume we cannot modify 'data' or the number of loops)*/\n\nint[] lookup = new int[256];\n\nfor (int c = 0; c &lt; 256; ++c)\n{\n    lookup[c] = (c &gt;= 128) ? c : 0;\n}\n\n// Test\nDateTime startTime = System.DateTime.Now;\nlong sum = 0;\n\nfor (int i = 0; i &lt; 100000; ++i)\n{\n    // Primary loop\n    for (int j = 0; j &lt; arraySize; ++j)\n    {\n        /* Here you basically want to use simple operations - so no\n        random branches, but things like &amp;, |, *, -, +, etc. are fine. */\n        sum += lookup[data[j]];\n    }\n}\n\nDateTime endTime = System.DateTime.Now;\nConsole.WriteLine(endTime - startTime);\nConsole.WriteLine(\"sum = \" + sum);\nConsole.ReadLine();\n</code></pre>\n"},{"comments":[{"owner":{"badge_counts":{"bronze":72,"silver":52,"gold":3},"reputation":27442,"user_id":1031591,"user_type":"registered","accept_rate":71,"profile_image":"https://i.stack.imgur.com/s3MiH.jpg?s=128&g=1","display_name":"atlaste","link":"https://stackoverflow.com/users/1031591/atlaste"},"edited":false,"score":36,"creation_date":1375099524,"post_id":17782979,"comment_id":26185793,"content_license":"CC BY-SA 3.0","body":"Right, you can also just use the bit directly and multiply (<code>data[c]&gt;&gt;7</code> - which is discussed somewhere here as well); I intentionally left this solution out, but of course you are correct. Just a small note: The rule of thumb for lookup tables is that if it fits in 4KB (because of caching), it&#39;ll work - preferably make the table as small as possible. For managed languages I&#39;d push that to 64KB, for low-level languages like C++ and C, I&#39;d probably reconsider (that&#39;s just my experience). Since <code>typeof(int) = 4</code>, I&#39;d try to stick to max 10 bits."},{"owner":{"badge_counts":{"bronze":112,"silver":85,"gold":18},"reputation":66604,"user_id":166949,"user_type":"registered","accept_rate":90,"profile_image":"https://i.stack.imgur.com/tIFie.png?s=128&g=1","display_name":"steveha","link":"https://stackoverflow.com/users/166949/steveha"},"reply_to_user":{"badge_counts":{"bronze":72,"silver":52,"gold":3},"reputation":27442,"user_id":1031591,"user_type":"registered","accept_rate":71,"profile_image":"https://i.stack.imgur.com/s3MiH.jpg?s=128&g=1","display_name":"atlaste","link":"https://stackoverflow.com/users/1031591/atlaste"},"edited":false,"score":24,"creation_date":1375135333,"post_id":17782979,"comment_id":26206652,"content_license":"CC BY-SA 3.0","body":"I think indexing with the 0/1 value will probably be faster than an integer multiply, but I guess if performance is really critical you should profile it.  I agree that small lookup tables are essential to avoid cache pressure, but clearly if you have a bigger cache you can get away with a bigger lookup table, so 4KB is more a rule of thumb than a hard rule.  I think you meant <code>sizeof(int) == 4</code>?  That would be true for 32-bit.  My two-year-old cell phone has a 32KB L1 cache, so even a 4K lookup table might work, especially if the lookup values were a byte instead of an int."},{"owner":{"badge_counts":{"bronze":70,"silver":47,"gold":5},"reputation":15612,"user_id":2187042,"user_type":"registered","accept_rate":53,"profile_image":"https://i.stack.imgur.com/otBg3.jpg?s=128&g=1","display_name":"Richard Tingle","link":"https://stackoverflow.com/users/2187042/richard-tingle"},"edited":false,"score":17,"creation_date":1393947504,"post_id":17782979,"comment_id":33658701,"content_license":"CC BY-SA 3.0","body":"Possibly I&#39;m missing something but in your <code>j</code> equals 0 or 1 method why don&#39;t you just multiply your value by <code>j</code> before adding it rather than using the array indexing (possibly should be multiplied by <code>1-j</code> rather than <code>j</code>)"},{"owner":{"badge_counts":{"bronze":72,"silver":52,"gold":3},"reputation":27442,"user_id":1031591,"user_type":"registered","accept_rate":71,"profile_image":"https://i.stack.imgur.com/s3MiH.jpg?s=128&g=1","display_name":"atlaste","link":"https://stackoverflow.com/users/1031591/atlaste"},"edited":false,"score":9,"creation_date":1395132305,"post_id":17782979,"comment_id":34186464,"content_license":"CC BY-SA 3.0","body":"@steveha Multiplication should be faster, I tried looking it up in the Intel books, but couldn&#39;t find it... either way, benchmarking also gives me that result here."},{"owner":{"badge_counts":{"bronze":72,"silver":52,"gold":3},"reputation":27442,"user_id":1031591,"user_type":"registered","accept_rate":71,"profile_image":"https://i.stack.imgur.com/s3MiH.jpg?s=128&g=1","display_name":"atlaste","link":"https://stackoverflow.com/users/1031591/atlaste"},"edited":false,"score":13,"creation_date":1395132731,"post_id":17782979,"comment_id":34186699,"content_license":"CC BY-SA 3.0","body":"@steveha P.S.: another possible answer would be <code>int c = data[j]; sum += c &amp; -(c &gt;&gt; 7);</code> which requires no multiplications at all."},{"owner":{"badge_counts":{"bronze":23,"silver":20,"gold":0},"reputation":3097,"user_id":3070062,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/f20c7574a287e2a9be02000157f65532?s=128&d=identicon&r=PG&f=1","display_name":"Falco","link":"https://stackoverflow.com/users/3070062/falco"},"edited":false,"score":1,"creation_date":1396451702,"post_id":17782979,"comment_id":34796004,"content_license":"CC BY-SA 3.0","body":"Good answer - since a lookup-table can also handle complex cases, where we cannot easily cheat with bit-manipulation"},{"owner":{"badge_counts":{"bronze":59,"silver":41,"gold":6},"reputation":32919,"user_id":116186,"user_type":"registered","accept_rate":77,"profile_image":"https://www.gravatar.com/avatar/dc5f7c3937e6844cb776d2004b903578?s=128&d=identicon&r=PG","display_name":"Petter","link":"https://stackoverflow.com/users/116186/petter"},"edited":false,"score":1,"creation_date":1404485763,"post_id":17782979,"comment_id":38070759,"content_license":"CC BY-SA 3.0","body":"Zain is correct. The “if” is just hidden in the lookup table. The code is faster because the lookup table is hidden OUTSIDE the 100000 iterations. There is nothign to gain from using a lookup table for this problem."},{"owner":{"badge_counts":{"bronze":27,"silver":20,"gold":2},"reputation":2229,"user_id":1685098,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/285de66759f2353fcbe6121465e10d04?s=128&d=identicon&r=PG","display_name":"Logan Pickup","link":"https://stackoverflow.com/users/1685098/logan-pickup"},"edited":false,"score":1,"creation_date":1414443702,"post_id":17782979,"comment_id":41807953,"content_license":"CC BY-SA 3.0","body":"<code>i = (x &lt; node-&gt;value); node = node-&gt;link[i];</code> doesn&#39;t have an explicit branch, but it still contains a comparison; it depends a lot on the target architecture as to whether this can be resolved without a branch or not. Since it can be done on x86 (using either CMOV or LAHF) and ARM (conditional add or move), which are the only architectures I use, this is possibly not important!"},{"owner":{"badge_counts":{"bronze":112,"silver":85,"gold":18},"reputation":66604,"user_id":166949,"user_type":"registered","accept_rate":90,"profile_image":"https://i.stack.imgur.com/tIFie.png?s=128&g=1","display_name":"steveha","link":"https://stackoverflow.com/users/166949/steveha"},"edited":false,"score":1,"creation_date":1414451157,"post_id":17782979,"comment_id":41810917,"content_license":"CC BY-SA 3.0","body":"On what architecture would an expression like <code>(x &lt; node-&gt;value)</code> require a branch to evaluate?  All the architectures with which I am familiar have a &quot;flags&quot; register, and it is simple to extract the desired flag value.  I guess on the Pentium 4 the flag bit extraction might be slow as IIRC that chip doesn&#39;t have dedicated shifting hardware for addresses, but borrows the ALU to shift bits.  But I don&#39;t know where an actual branch would be needed.  Hmm, your examples were conditional... the idea is that once you extract the bit from flags, you can just use indexing with no branch."},{"owner":{"badge_counts":{"bronze":26,"silver":29,"gold":2},"reputation":5832,"user_id":3950982,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/7491f45ae073ed6bfe01b1e63fb06bf0?s=128&d=identicon&r=PG","display_name":"Luke Hutchison","link":"https://stackoverflow.com/users/3950982/luke-hutchison"},"edited":false,"score":1,"creation_date":1551357444,"post_id":17782979,"comment_id":96616372,"content_license":"CC BY-SA 4.0","body":"Bit shifting is a zero-cost operation in ARM, so you may find the bit-shifted version is faster on ARM."},{"owner":{"badge_counts":{"bronze":123,"silver":94,"gold":21},"reputation":27825,"user_id":63550,"user_type":"registered","accept_rate":78,"profile_image":"https://i.stack.imgur.com/RIZKi.png?s=128&g=1","display_name":"Peter Mortensen","link":"https://stackoverflow.com/users/63550/peter-mortensen"},"edited":false,"score":1,"creation_date":1558962425,"post_id":17782979,"comment_id":99261002,"content_license":"CC BY-SA 4.0","body":"What about cache sizes, L1, L2, etc.? Having to go to main memory for a table lookup would be killer. Can you address that in your answer?"}],"tags":[],"owner":{"badge_counts":{"bronze":112,"silver":85,"gold":18},"reputation":66604,"user_id":166949,"user_type":"registered","accept_rate":90,"profile_image":"https://i.stack.imgur.com/tIFie.png?s=128&g=1","display_name":"steveha","link":"https://stackoverflow.com/users/166949/steveha"},"last_editor":{"badge_counts":{"bronze":4,"silver":1,"gold":0},"reputation":21,"user_id":13367995,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/5a484de967e1aaf9619028a9f828e259?s=128&d=identicon&r=PG&f=1","display_name":"jakubde","link":"https://stackoverflow.com/users/13367995/jakubde"},"comment_count":11,"up_vote_count":1198,"is_accepted":false,"score":1195,"last_activity_date":1611741816,"last_edit_date":1611741816,"creation_date":1374481770,"answer_id":17782979,"question_id":11227809,"content_license":"CC BY-SA 4.0","body":"<p>One way to avoid branch prediction errors is to build a lookup table, and index it using the data.  Stefan de Bruijn discussed that in his answer.</p>\n<p>But in this case, we know values are in the range [0, 255] and we only care about values &gt;= 128.  That means we can easily extract a single bit that will tell us whether we want a value or not: by shifting the data to the right 7 bits, we are left with a 0 bit or a 1 bit, and we only want to add the value when we have a 1 bit.  Let's call this bit the &quot;decision bit&quot;.</p>\n<p>By using the 0/1 value of the decision bit as an index into an array, we can make code that will be equally fast whether the data is sorted or not sorted.  Our code will always add a value, but when the decision bit is 0, we will add the value somewhere we don't care about.  Here's the code:</p>\n<pre><code>// Test\nclock_t start = clock();\nlong long a[] = {0, 0};\nlong long sum;\n\nfor (unsigned i = 0; i &lt; 100000; ++i)\n{\n    // Primary loop\n    for (unsigned c = 0; c &lt; arraySize; ++c)\n    {\n        int j = (data[c] &gt;&gt; 7);\n        a[j] += data[c];\n    }\n}\n\ndouble elapsedTime = static_cast&lt;double&gt;(clock() - start) / CLOCKS_PER_SEC;\nsum = a[1];\n</code></pre>\n<p>This code wastes half of the adds but never has a branch prediction failure.  It's tremendously faster on random data than the version with an actual if statement.</p>\n<p>But in my testing, an explicit lookup table was slightly faster than this, probably because indexing into a lookup table was slightly faster than bit shifting.  This shows how my code sets up and uses the lookup table (unimaginatively called <code>lut</code> for &quot;LookUp Table&quot; in the code).  Here's the C++ code:</p>\n<pre><code>// Declare and then fill in the lookup table\nint lut[256];\nfor (unsigned c = 0; c &lt; 256; ++c)\n    lut[c] = (c &gt;= 128) ? c : 0;\n\n// Use the lookup table after it is built\nfor (unsigned i = 0; i &lt; 100000; ++i)\n{\n    // Primary loop\n    for (unsigned c = 0; c &lt; arraySize; ++c)\n    {\n        sum += lut[data[c]];\n    }\n}\n</code></pre>\n<p>In this case, the lookup table was only 256 bytes, so it fits nicely in a cache and all was fast.  This technique wouldn't work well if the data was 24-bit values and we only wanted half of them... the lookup table would be far too big to be practical.  On the other hand, we can combine the two techniques shown above: first shift the bits over, then index a lookup table.  For a 24-bit value that we only want the top half value, we could potentially shift the data right by 12 bits, and be left with a 12-bit value for a table index.  A 12-bit table index implies a table of 4096 values, which might be practical.</p>\n<p>The technique of indexing into an array, instead of using an <code>if</code> statement, can be used for deciding which pointer to use.  I saw a library that implemented binary trees, and instead of having two named pointers (<code>pLeft</code> and <code>pRight</code> or whatever) had a length-2 array of pointers and used the &quot;decision bit&quot; technique to decide which one to follow.  For example, instead of:</p>\n<pre><code>if (x &lt; node-&gt;value)\n    node = node-&gt;pLeft;\nelse\n    node = node-&gt;pRight;\n</code></pre>\n<p>this library would do something like:</p>\n<pre><code>i = (x &lt; node-&gt;value);\nnode = node-&gt;link[i];\n</code></pre>\n<p>Here's a link to this code: <a href=\"https://web.archive.org/web/20190207151651/https://www.eternallyconfuzzled.com/tuts/datastructures/jsw_tut_rbtree.aspx\" rel=\"noreferrer\">Red Black Trees</a>, <em>Eternally Confuzzled</em></p>\n"},{"comments":[{"owner":{"badge_counts":{"bronze":559,"silver":412,"gold":43},"reputation":323972,"user_id":85371,"user_type":"registered","accept_rate":43,"profile_image":"https://www.gravatar.com/avatar/6d52c235ec6dd15f30bab444103e7af2?s=128&d=identicon&r=PG","display_name":"sehe","link":"https://stackoverflow.com/users/85371/sehe"},"edited":false,"score":28,"creation_date":1374683490,"post_id":17828251,"comment_id":26040119,"content_license":"CC BY-SA 3.0","body":"<code>sum= 3137536</code> - clever. That&#39;s kinda obviously not the point of the question. The question is clearly about explaining surprising performance characteristics. I&#39;m inclined to say that the addition of doing <code>std::partition</code> instead of <code>std::sort</code> is valuable. Though the actual question extends to more than just the synthetic benchmark given."},{"owner":{"badge_counts":{"bronze":83,"silver":39,"gold":8},"reputation":48201,"user_id":1196549,"user_type":"registered","accept_rate":46,"profile_image":"https://www.gravatar.com/avatar/fa597bf0dc47449a25e1f7f5b57e3ef1?s=128&d=identicon&r=PG","display_name":"Yves Daoust","link":"https://stackoverflow.com/users/1196549/yves-daoust"},"reply_to_user":{"badge_counts":{"bronze":445,"silver":230,"gold":32},"reputation":138476,"user_id":298661,"user_type":"registered","accept_rate":82,"profile_image":"https://www.gravatar.com/avatar/3445f56229632874a44596385ed6d40c?s=128&d=identicon&r=PG","display_name":"Puppy","link":"https://stackoverflow.com/users/298661/puppy"},"edited":false,"score":15,"creation_date":1374698251,"post_id":17828251,"comment_id":26048383,"content_license":"CC BY-SA 3.0","body":"@DeadMG: this is indeed not the standard dichotomic search for a given key, but a search for the partitioning index; it requires a single compare per iteration. But don&#39;t rely on this code, I have not checked it. If you are interested in a guaranteed correct implementation, let me know."}],"tags":[],"owner":{"badge_counts":{"bronze":83,"silver":39,"gold":8},"reputation":48201,"user_id":1196549,"user_type":"registered","accept_rate":46,"profile_image":"https://www.gravatar.com/avatar/fa597bf0dc47449a25e1f7f5b57e3ef1?s=128&d=identicon&r=PG","display_name":"Yves Daoust","link":"https://stackoverflow.com/users/1196549/yves-daoust"},"last_editor":{"badge_counts":{"bronze":14,"silver":10,"gold":0},"reputation":929,"user_id":710069,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/74bbef6437ca6a5a9158601455d7a534?s=128&d=identicon&r=PG","display_name":"Konard","link":"https://stackoverflow.com/users/710069/konard"},"comment_count":2,"up_vote_count":1084,"is_accepted":false,"score":1082,"last_activity_date":1557574272,"last_edit_date":1557574272,"creation_date":1374652659,"answer_id":17828251,"question_id":11227809,"content_license":"CC BY-SA 4.0","body":"<p>In the sorted case, you can do better than relying on successful branch prediction or any branchless comparison trick: completely remove the branch.</p>\n\n<p>Indeed, the array is partitioned in a contiguous zone with <code>data &lt; 128</code> and another with <code>data &gt;= 128</code>. So you should find the partition point with a <a href=\"https://en.wikipedia.org/wiki/Dichotomic_search\" rel=\"noreferrer\">dichotomic search</a> (using <code>Lg(arraySize) = 15</code> comparisons), then do a straight accumulation from that point.</p>\n\n<p>Something like (unchecked)</p>\n\n<pre><code>int i= 0, j, k= arraySize;\nwhile (i &lt; k)\n{\n  j= (i + k) &gt;&gt; 1;\n  if (data[j] &gt;= 128)\n    k= j;\n  else\n    i= j;\n}\nsum= 0;\nfor (; i &lt; arraySize; i++)\n  sum+= data[i];\n</code></pre>\n\n<p>or, slightly more obfuscated</p>\n\n<pre><code>int i, k, j= (i + k) &gt;&gt; 1;\nfor (i= 0, k= arraySize; i &lt; k; (data[j] &gt;= 128 ? k : i)= j)\n  j= (i + k) &gt;&gt; 1;\nfor (sum= 0; i &lt; arraySize; i++)\n  sum+= data[i];\n</code></pre>\n\n<p>A yet faster approach, that gives an <strong>approximate</strong> solution for both sorted or unsorted is: <code>sum= 3137536;</code> (assuming a truly uniform distribution, 16384 samples with expected value 191.5) <strong>:-)</strong></p>\n"},{"comments":[{"owner":{"badge_counts":{"bronze":95,"silver":48,"gold":6},"reputation":16538,"user_id":4767498,"user_type":"registered","accept_rate":87,"profile_image":"https://lh3.googleusercontent.com/-u6daZXYwzxs/AAAAAAAAAAI/AAAAAAAAABI/0xXoH0XUtkc/photo.jpg?sz=128","display_name":"M.kazem Akhgary","link":"https://stackoverflow.com/users/4767498/m-kazem-akhgary"},"edited":false,"score":2,"creation_date":1507733382,"post_id":31210295,"comment_id":80330289,"content_license":"CC BY-SA 3.0","body":"how are two instructions executed together? is this done with separate cpu cores or is pipeline instruction is integrated in single cpu core?"},{"owner":{"badge_counts":{"bronze":21,"silver":10,"gold":0},"reputation":1309,"user_id":6583956,"user_type":"registered","accept_rate":71,"profile_image":"https://i.stack.imgur.com/rM8OA.jpg?s=128&g=1","display_name":"Sergey.quixoticaxis.Ivanov","link":"https://stackoverflow.com/users/6583956/sergey-quixoticaxis-ivanov"},"reply_to_user":{"badge_counts":{"bronze":95,"silver":48,"gold":6},"reputation":16538,"user_id":4767498,"user_type":"registered","accept_rate":87,"profile_image":"https://lh3.googleusercontent.com/-u6daZXYwzxs/AAAAAAAAAAI/AAAAAAAAABI/0xXoH0XUtkc/photo.jpg?sz=128","display_name":"M.kazem Akhgary","link":"https://stackoverflow.com/users/4767498/m-kazem-akhgary"},"edited":false,"score":2,"creation_date":1509695112,"post_id":31210295,"comment_id":81130628,"content_license":"CC BY-SA 3.0","body":"@M.kazemAkhgary It&#39;s all inside one logical core. If you&#39;re interested, this is nicely described for example in <a href=\"https://software.intel.com/en-us/articles/intel-sdm\" rel=\"nofollow noreferrer\">Intel Software Developer Manual</a>"}],"tags":[],"owner":{"badge_counts":{"bronze":24,"silver":13,"gold":2},"reputation":9514,"user_id":1627741,"user_type":"registered","accept_rate":53,"profile_image":"https://i.stack.imgur.com/YXvvz.jpg?s=128&g=1","display_name":"Harsh Sharma","link":"https://stackoverflow.com/users/1627741/harsh-sharma"},"last_editor":{"badge_counts":{"bronze":27,"silver":11,"gold":2},"reputation":1130,"user_id":2326172,"user_type":"registered","accept_rate":78,"profile_image":"https://www.gravatar.com/avatar/3f5b227ebadd36dac233264cfeaf4198?s=128&d=identicon&r=PG","display_name":"Saheb","link":"https://stackoverflow.com/users/2326172/saheb"},"comment_count":2,"up_vote_count":882,"is_accepted":false,"score":882,"last_activity_date":1523391206,"last_edit_date":1523391206,"creation_date":1435937752,"answer_id":31210295,"question_id":11227809,"content_license":"CC BY-SA 3.0","body":"<p>The above behavior is happening because of Branch prediction.</p>\n\n<p>To understand branch prediction one must first understand <strong>Instruction Pipeline</strong>:</p>\n\n<p>Any instruction is broken into a sequence of steps so that different steps can be executed concurrently in parallel. This technique is known as instruction pipeline and this is used to increase throughput in modern processors. To understand this better please see this <a href=\"https://en.wikipedia.org/wiki/Pipeline_(computing)#Concept_and_motivation\" rel=\"noreferrer\">example on Wikipedia</a>.</p>\n\n<p>Generally, modern processors have quite long pipelines, but for ease let's consider these 4 steps only.</p>\n\n<ol>  \n  <li>IF -- Fetch the instruction from memory \n  <li>ID -- Decode the instruction\n  <li>EX -- Execute the instruction \n  <li>WB -- Write back to CPU register\n</ol>\n\n<p><strong><em>4-stage pipeline in general for 2 instructions.</em></strong>\n<img src=\"https://i.stack.imgur.com/PqBBR.png\" alt=\"4-stage pipeline in general\"></p>\n\n<p>Moving back to the above question let's consider the following instructions:</p>\n\n<pre><code>                        A) if (data[c] &gt;= 128)\n                                /\\\n                               /  \\\n                              /    \\\n                        true /      \\ false\n                            /        \\\n                           /          \\\n                          /            \\\n                         /              \\\n              B) sum += data[c];          C) for loop or print().\n</code></pre>\n\n<p>Without branch prediction, the following would occur:</p>\n\n<p>To execute instruction B or instruction C the processor will have to wait till the instruction A doesn't reach till EX stage in the pipeline, as the decision to go to instruction B or instruction C depends on the result of instruction A. So the pipeline will look like this.</p>\n\n<p><strong><em>when if condition returns true:</em></strong>\n<img src=\"https://i.stack.imgur.com/0H4gP.png\" alt=\"enter image description here\"></p>\n\n<p><strong><em>When if condition returns false:</em></strong>\n<img src=\"https://i.stack.imgur.com/APpca.png\" alt=\"enter image description here\"></p>\n\n<p>As a result of waiting for the result of instruction A, the total CPU cycles spent in the above case (without branch prediction; for both true and false) is 7.</p>\n\n<p><strong>So what is branch prediction?</strong></p>\n\n<p>Branch predictor will try to guess which way a branch (an if-then-else structure) will go before this is known for sure. It will not wait for the instruction A to reach the EX stage of the pipeline, but it will guess the decision and go to that instruction (B or C in case of our example).</p>\n\n<p><strong><em>In case of a correct guess, the pipeline looks something like this:</em></strong>\n<img src=\"https://i.stack.imgur.com/ZYUbs.png\" alt=\"enter image description here\"></p>\n\n<p>If it is later detected that the guess was wrong then the partially executed instructions are discarded and the pipeline starts over with the correct branch, incurring a delay. \nThe time that is wasted in case of a branch misprediction is equal to the number of stages in the pipeline from the fetch stage to the execute stage. Modern microprocessors tend to have quite long pipelines so that the misprediction delay is between 10 and 20 clock cycles. The longer the pipeline the greater the need for a good <a href=\"https://en.wikipedia.org/wiki/Branch_predictor\" rel=\"noreferrer\">branch predictor</a>.</p>\n\n<p>In the OP's code, the first time when the conditional, the branch predictor does not have any information to base up prediction, so the first time it will randomly choose the next instruction. Later in the for loop, it can base the prediction on the history. \nFor an array sorted in ascending order, there are three possibilities:</p>\n\n<ol>\n<li> All the elements are less than 128\n<li> All the elements are greater than 128\n<li> Some starting new elements are less than 128 and later it become greater than 128\n</ol>\n\n<p>Let us assume that the predictor will always assume the true branch on the first run.</p>\n\n<p>So in the first case, it will always take the true branch since historically all its predictions are correct.\nIn the 2nd case, initially it will predict wrong, but after a few iterations, it will predict correctly.\nIn the 3rd case, it will initially predict correctly till the elements are less than 128. After which it will fail for some time and the correct itself when it sees branch prediction failure in history. </p>\n\n<p>In all these cases the failure will be too less in number and as a result, only a few times it will need to discard the partially executed instructions and start over with the correct branch, resulting in fewer CPU cycles. </p>\n\n<p>But in case of a random unsorted array, the prediction will need to discard the partially executed instructions and start over with the correct branch most of the time and result in more CPU cycles compared to the sorted array.</p>\n"},{"tags":[],"owner":{"badge_counts":{"bronze":55,"silver":34,"gold":5},"reputation":13624,"user_id":1313233,"user_type":"registered","accept_rate":82,"profile_image":"https://i.stack.imgur.com/hBeXC.png?s=128&g=1","display_name":"rkachach","link":"https://stackoverflow.com/users/1313233/rkachach"},"last_editor":{"badge_counts":{"bronze":68,"silver":51,"gold":5},"reputation":5598,"user_id":1372621,"user_type":"registered","accept_rate":71,"profile_image":"https://i.stack.imgur.com/0fqUn.jpg?s=128&g=1","display_name":"Stacked","link":"https://stackoverflow.com/users/1372621/stacked"},"awarded_bounty_amount":100,"comment_count":0,"up_vote_count":747,"is_accepted":false,"score":746,"last_activity_date":1477650491,"last_edit_date":1477650491,"creation_date":1443020267,"answer_id":32742980,"question_id":11227809,"content_license":"CC BY-SA 3.0","body":"<p>In the same line (I think this was not highlighted by any answer) it's good to mention that sometimes (specially in software where the performance matters—like in the Linux kernel) you can find some if statements like the following:</p>\n\n<pre><code>if (likely( everything_is_ok ))\n{\n    /* Do something */\n}\n</code></pre>\n\n<p>or similarly:</p>\n\n<pre><code>if (unlikely(very_improbable_condition))\n{\n    /* Do something */    \n}\n</code></pre>\n\n<p>Both <code>likely()</code> and <code>unlikely()</code> are in fact macros that are defined by using something like the GCC's <code>__builtin_expect</code> to help the compiler insert prediction code to favour the condition taking into account the information provided by the user. GCC supports other builtins that could change the behavior of the running program or emit low level instructions like clearing the cache, etc. See <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\" rel=\"noreferrer\">this documentation</a> that goes through the available GCC's builtins.</p>\n\n<p>Normally this kind of optimizations are mainly found in hard-real time applications or embedded systems where execution time matters and it's critical. For example, if you are checking for some error condition that only happens 1/10000000 times, then why not inform the compiler about this? This way, by default, the branch prediction would assume that the condition is false.</p>\n"},{"tags":[],"owner":{"badge_counts":{"bronze":16,"silver":12,"gold":2},"reputation":8355,"user_id":4895229,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/cc00fb71bd8f252a7ec9fc4216f58c0b?s=128&d=identicon&r=PG&f=1","display_name":"Maciej","link":"https://stackoverflow.com/users/4895229/maciej"},"last_editor":{"badge_counts":{"bronze":33,"silver":18,"gold":1},"reputation":2161,"user_id":7405477,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/dd51e9eabda0dffc93ef9f0767ad081c?s=128&d=identicon&r=PG&f=1","display_name":"Sujal Patel","link":"https://stackoverflow.com/users/7405477/sujal-patel"},"awarded_bounty_amount":25,"comment_count":0,"up_vote_count":738,"is_accepted":false,"score":735,"last_activity_date":1559234066,"last_edit_date":1559234066,"creation_date":1444437042,"answer_id":33048998,"question_id":11227809,"content_license":"CC BY-SA 4.0","body":"<p>Frequently used Boolean operations in C++ produce many branches in the compiled program. If these branches are inside loops and are hard to predict they can slow down execution significantly. Boolean variables are stored as 8-bit integers with the value <code>0</code> for <code>false</code> and <code>1</code> for <code>true</code>.</p>\n\n<p>Boolean variables are overdetermined in the sense that all operators that have Boolean variables as input check if the inputs have any other value than <code>0</code> or <code>1</code>, but operators that have Booleans as output can produce no other value than <code>0</code> or <code>1</code>. This makes operations with Boolean variables as input less efficient than necessary.\nConsider example:</p>\n\n<pre><code>bool a, b, c, d;\nc = a &amp;&amp; b;\nd = a || b;\n</code></pre>\n\n<p>This is typically implemented by the compiler in the following way:</p>\n\n<pre><code>bool a, b, c, d;\nif (a != 0) {\n    if (b != 0) {\n        c = 1;\n    }\n    else {\n        goto CFALSE;\n    }\n}\nelse {\n    CFALSE:\n    c = 0;\n}\nif (a == 0) {\n    if (b == 0) {\n        d = 0;\n    }\n    else {\n        goto DTRUE;\n    }\n}\nelse {\n    DTRUE:\n    d = 1;\n}\n</code></pre>\n\n<p>This code is far from optimal. The branches may take a long time in case of mispredictions. The Boolean operations can be made much more efficient if it is known with certainty that the operands have no other values than <code>0</code> and <code>1</code>. The reason why the compiler does not make such an assumption is that the variables might have other values if they are uninitialized or come from unknown sources. The above code can be optimized if <code>a</code> and <code>b</code> has been initialized to valid values or if they come from operators that produce Boolean output. The optimized code looks like this:</p>\n\n<pre><code>char a = 0, b = 1, c, d;\nc = a &amp; b;\nd = a | b;\n</code></pre>\n\n<p><code>char</code> is used instead of <code>bool</code> in order to make it possible to use the bitwise operators (<code>&amp;</code> and <code>|</code>) instead of the Boolean operators (<code>&amp;&amp;</code> and <code>||</code>). The bitwise operators are single instructions that take only one clock cycle. The OR operator (<code>|</code>) works even if <code>a</code> and <code>b</code> have other values than <code>0</code> or <code>1</code>. The AND operator (<code>&amp;</code>) and the EXCLUSIVE OR operator (<code>^</code>) may give inconsistent results if the operands have other values than <code>0</code> and <code>1</code>.</p>\n\n<p><code>~</code> can not be used for NOT. Instead, you can make a Boolean NOT on a variable which is known to be <code>0</code> or <code>1</code> by XOR'ing it with <code>1</code>:</p>\n\n<pre><code>bool a, b;\nb = !a;\n</code></pre>\n\n<p>can be optimized to:</p>\n\n<pre><code>char a = 0, b;\nb = a ^ 1;\n</code></pre>\n\n<p><code>a &amp;&amp; b</code> cannot be replaced with <code>a &amp; b</code> if <code>b</code> is an expression that should not be evaluated if <code>a</code> is <code>false</code> ( <code>&amp;&amp;</code> will not evaluate <code>b</code>, <code>&amp;</code> will). Likewise, <code>a || b</code> can not be replaced with <code>a | b</code> if <code>b</code> is an expression that should not be evaluated if <code>a</code> is <code>true</code>.</p>\n\n<p>Using bitwise operators is more advantageous if the operands are variables than if the operands are comparisons:</p>\n\n<pre><code>bool a; double x, y, z;\na = x &gt; y &amp;&amp; z &lt; 5.0;\n</code></pre>\n\n<p>is optimal in most cases (unless you expect the <code>&amp;&amp;</code> expression to generate many branch mispredictions).</p>\n"},{"tags":[],"owner":{"badge_counts":{"bronze":35,"silver":20,"gold":3},"reputation":13552,"user_id":4013258,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/1d423395e1033fa23d80a5561ab170fa?s=128&d=identicon&r=PG&f=1","display_name":"Surt","link":"https://stackoverflow.com/users/4013258/surt"},"last_editor":{"badge_counts":{"bronze":101,"silver":64,"gold":13},"reputation":18771,"user_id":234175,"user_type":"registered","accept_rate":92,"profile_image":"https://www.gravatar.com/avatar/37f386df1c4e98d9ce0350431f590f2a?s=128&d=identicon&r=PG","display_name":"greatwolf","link":"https://stackoverflow.com/users/234175/greatwolf"},"comment_count":0,"up_vote_count":777,"is_accepted":false,"score":776,"last_activity_date":1485862773,"last_edit_date":1485862773,"creation_date":1444597518,"answer_id":33070112,"question_id":11227809,"content_license":"CC BY-SA 3.0","body":"<p>An official answer would be from</p>\n\n<ol>\n<li><a href=\"https://software.intel.com/en-us/articles/avoiding-the-cost-of-branch-misprediction\" rel=\"noreferrer\">Intel - Avoiding the Cost of Branch Misprediction</a></li>\n<li><a href=\"https://software.intel.com/en-us/articles/branch-and-loop-reorganization-to-prevent-mispredicts\" rel=\"noreferrer\">Intel - Branch and Loop Reorganization to Prevent Mispredicts</a></li>\n<li><a href=\"https://scholar.google.com/scholar?q=branch%20prediction%20computer%20architecture&amp;hl=da&amp;as_sdt=0&amp;as_vis=1&amp;oi=scholart\" rel=\"noreferrer\">Scientific papers - branch prediction computer architecture</a></li>\n<li>Books: J.L. Hennessy, D.A. Patterson: Computer architecture: a quantitative approach</li>\n<li>Articles in scientific publications: T.Y. Yeh, Y.N. Patt made a lot of these on branch predictions.</li>\n</ol>\n\n<p>You can also see from this lovely <a href=\"https://en.wikipedia.org/wiki/Branch_predictor#/media/File:Branch_prediction_2bit_saturating_counter-dia.svg\" rel=\"noreferrer\">diagram</a> why the branch predictor gets confused.</p>\n\n<p><a href=\"https://i.stack.imgur.com/pBMV2.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/pBMV2.png\" alt=\"2-bit state diagram\"></a></p>\n\n<p>Each element in the original code is a random value</p>\n\n<pre><code>data[c] = std::rand() % 256;\n</code></pre>\n\n<p>so the predictor will change sides as the <code>std::rand()</code> blow.</p>\n\n<p>On the other hand, once it's sorted, the predictor will first move into a state of strongly not taken and when the values change to the high value the predictor will in three runs through change all the way from strongly not taken to strongly taken.</p>\n\n<hr>\n"},{"comments":[{"owner":{"badge_counts":{"bronze":123,"silver":94,"gold":21},"reputation":27825,"user_id":63550,"user_type":"registered","accept_rate":78,"profile_image":"https://i.stack.imgur.com/RIZKi.png?s=128&g=1","display_name":"Peter Mortensen","link":"https://stackoverflow.com/users/63550/peter-mortensen"},"edited":false,"score":3,"creation_date":1521204439,"post_id":41603849,"comment_id":85643214,"content_license":"CC BY-SA 3.0","body":"That is a very interesting article (in fact, I have just read all of it), but how does it answer the question?"},{"owner":{"badge_counts":{"bronze":33,"silver":23,"gold":3},"reputation":5206,"user_id":601567,"user_type":"registered","accept_rate":75,"profile_image":"https://www.gravatar.com/avatar/354e6825881d0dbb29130bdd4c0e560e?s=128&d=identicon&r=PG","display_name":"ForeverLearning","link":"https://stackoverflow.com/users/601567/foreverlearning"},"reply_to_user":{"badge_counts":{"bronze":123,"silver":94,"gold":21},"reputation":27825,"user_id":63550,"user_type":"registered","accept_rate":78,"profile_image":"https://i.stack.imgur.com/RIZKi.png?s=128&g=1","display_name":"Peter Mortensen","link":"https://stackoverflow.com/users/63550/peter-mortensen"},"edited":false,"score":2,"creation_date":1521214636,"post_id":41603849,"comment_id":85650402,"content_license":"CC BY-SA 3.0","body":"@PeterMortensen I am a bit flummoxed by your question. For example here is one relevant line from that piece:  <code>When the input is unsorted, all the rest of the loop takes substantial time. But with sorted input, the processor is somehow able to spend not just less time in the body of the loop, meaning the buckets at offsets 0x18 and 0x1C, but vanishingly little time on the mechanism of looping.</code>  Author is trying to discuss profiling in the context of code posted here and in the process trying to explain why the sorted case is so much more faster."}],"tags":[],"owner":{"badge_counts":{"bronze":33,"silver":23,"gold":3},"reputation":5206,"user_id":601567,"user_type":"registered","accept_rate":75,"profile_image":"https://www.gravatar.com/avatar/354e6825881d0dbb29130bdd4c0e560e?s=128&d=identicon&r=PG","display_name":"ForeverLearning","link":"https://stackoverflow.com/users/601567/foreverlearning"},"last_editor":{"badge_counts":{"bronze":103,"silver":60,"gold":6},"reputation":41420,"user_id":3204551,"user_type":"registered","accept_rate":75,"profile_image":"https://www.gravatar.com/avatar/91bb06155f79d40ffecdf124deecb001?s=128&d=identicon&r=PG&f=1","display_name":"Deduplicator","link":"https://stackoverflow.com/users/3204551/deduplicator"},"comment_count":2,"up_vote_count":352,"is_accepted":false,"score":350,"last_activity_date":1610293840,"last_edit_date":1610293840,"creation_date":1484185828,"answer_id":41603849,"question_id":11227809,"content_license":"CC BY-SA 4.0","body":"<p>This question has already been answered excellently many times over. Still I'd like to draw the group's attention to yet another interesting analysis.</p>\n<p>Recently this example (modified very slightly) was also used as a way to demonstrate how a piece of code can be profiled within the program itself on Windows. Along the way, the author also shows how to use the results to determine where the code is spending most of its time in both the sorted &amp; unsorted case. Finally the piece also shows how to use a little known feature of the HAL (Hardware Abstraction Layer) to determine just how much branch misprediction is happening in the unsorted case.</p>\n<p>The link is here:\n<a href=\"//www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm\" rel=\"noreferrer\"><strong>A Demonstration of Self-Profiling</strong></a></p>\n"},{"tags":[],"owner":{"badge_counts":{"bronze":150,"silver":238,"gold":19},"reputation":81976,"user_id":5423108,"user_type":"registered","profile_image":"https://i.stack.imgur.com/WtfBG.png?s=128&g=1","display_name":"Alireza","link":"https://stackoverflow.com/users/5423108/alireza"},"last_editor":{"badge_counts":{"bronze":0,"silver":1,"gold":0},"reputation":1,"user_id":-1,"user_type":"moderator","profile_image":"https://www.gravatar.com/avatar/a007be5a61f6aa8f3e85ae2fc18dd66e?s=128&d=identicon&r=PG","display_name":"Community","link":"https://stackoverflow.com/users/-1/community"},"comment_count":0,"up_vote_count":390,"is_accepted":false,"score":390,"last_activity_date":1525329351,"last_edit_date":1592644375,"creation_date":1497786043,"answer_id":44614591,"question_id":11227809,"content_license":"CC BY-SA 4.0","body":"<p>That's for sure!...</p>\n<p><strong>Branch prediction</strong> makes the logic run slower, because of the switching which happens in your code! It's like you are going a straight street or a street with a lot of turnings, for sure the straight one is going to be done quicker!...</p>\n<p>If the array is sorted, your condition is false at the first step: <code>data[c] &gt;= 128</code>, then becomes a true value for the whole way to the end of the street. That's how you get to the end of the logic faster. On the other hand, using an unsorted array, you need a lot of turning and processing which make your code run slower for sure...</p>\n<p>Look at the image I created for you below. Which street is going to be finished faster?</p>\n<p><a href=\"https://i.stack.imgur.com/cSmCa.jpg\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/cSmCa.jpg\" alt=\"Branch Prediction\" /></a></p>\n<p>So programmatically, <strong>branch prediction</strong> causes the process to be slower...</p>\n<p>Also at the end, it's good to know we have two kinds of branch predictions that each is going to affect your code differently:</p>\n<p><strong>1. Static</strong></p>\n<p><strong>2. Dynamic</strong></p>\n<p><a href=\"https://i.stack.imgur.com/ZfhDu.jpg\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/ZfhDu.jpg\" alt=\"Branch Prediction\" /></a></p>\n<blockquote>\n<p>Static branch prediction is used by the microprocessor the first time\na conditional branch is encountered, and dynamic branch prediction is\nused for succeeding executions of the conditional branch code.</p>\n<p>In order to effectively write your code to take advantage of these\nrules, when writing <strong>if-else</strong> or <strong>switch</strong> statements, check the most\ncommon cases first and work progressively down to the least common.\nLoops do not necessarily require any special ordering of code for\nstatic branch prediction, as only the condition of the loop iterator\nis normally used.</p>\n</blockquote>\n"},{"comments":[{"owner":{"badge_counts":{"bronze":583,"silver":405,"gold":34},"reputation":236255,"user_id":224132,"user_type":"registered","accept_rate":83,"profile_image":"https://i.stack.imgur.com/N4ivW.png?s=128&g=1","display_name":"Peter Cordes","link":"https://stackoverflow.com/users/224132/peter-cordes"},"edited":false,"score":0,"creation_date":1581307668,"post_id":45503985,"comment_id":106374699,"content_license":"CC BY-SA 4.0","body":"<i>While flushing pipelines is super fast</i>  Not really.  It&#39;s fast compared to a cache miss all the way to DRAM, but on a modern high-performance x86 (like Intel Sandybridge-family) it&#39;s about a dozen cycles.  Although fast recovery does allow it to avoid waiting for all older independent instructions to reach retirement before starting recovery, you still lose a lot of front-end cycles on a mispredict.  <a href=\"//stackoverflow.com/q/50984007\">What exactly happens when a skylake CPU mispredicts a branch?</a>.  (And each cycle can be about 4 instructions of work.)  Bad for high-throughput code."}],"tags":[],"owner":{"badge_counts":{"bronze":71,"silver":38,"gold":7},"reputation":11642,"user_id":6530695,"user_type":"registered","accept_rate":98,"profile_image":"https://www.gravatar.com/avatar/53a7a617c8e419f2562f0b00e6be10b1?s=128&d=identicon&r=PG&f=1","display_name":"Tony Tannous","link":"https://stackoverflow.com/users/6530695/tony-tannous"},"last_editor":{"badge_counts":{"bronze":0,"silver":1,"gold":0},"reputation":1,"user_id":-1,"user_type":"moderator","profile_image":"https://www.gravatar.com/avatar/a007be5a61f6aa8f3e85ae2fc18dd66e?s=128&d=identicon&r=PG","display_name":"Community","link":"https://stackoverflow.com/users/-1/community"},"comment_count":1,"up_vote_count":246,"is_accepted":false,"score":246,"last_activity_date":1521203445,"last_edit_date":1592644375,"creation_date":1501841232,"answer_id":45503985,"question_id":11227809,"content_license":"CC BY-SA 4.0","body":"<p><strong>Branch-prediction gain!</strong></p>\n<p>It is important to understand that branch misprediction doesn't slow down programs. The cost of a missed prediction is just as if branch prediction didn't exist and you waited for the evaluation of the expression to decide what code to run (further explanation in the next paragraph).</p>\n<pre><code>if (expression)\n{\n    // Run 1\n} else {\n    // Run 2\n}\n</code></pre>\n<p>Whenever there's an <code>if-else</code> \\ <code>switch</code> statement, the expression has to be evaluated to determine which block should be executed. In the assembly code generated by the compiler, conditional <a href=\"https://en.wikipedia.org/wiki/Branch_(computer_science)\" rel=\"noreferrer\">branch</a> instructions are inserted.</p>\n<p>A branch instruction can cause a computer to begin executing a different instruction sequence and thus deviate from its default behavior of executing instructions in order (i.e. if the expression is false, the program skips the code of the <code>if</code> block) depending on some condition, which is the expression evaluation in our case.</p>\n<p>That being said, the compiler tries to predict the outcome prior to it being actually evaluated. It will fetch instructions from the <code>if</code> block, and if the expression turns out to be true, then wonderful! We gained the time it took to evaluate it and made progress in the code; if not then we are running the wrong code, the pipeline is flushed, and the correct block is run.</p>\n<h3>Visualization:</h3>\n<p>Let's say you need to pick route 1 or route 2. Waiting for your partner to check the map, you have stopped at ## and waited, or you could just pick route1 and if you were lucky (route 1 is the correct route), then great you didn't have to wait for your partner to check the map (you saved the time it would have taken him to check the map), otherwise you will just turn back.</p>\n<p>While flushing pipelines is super fast, nowadays taking this gamble is worth it. Predicting sorted data or a data that changes slowly is always easier and better than predicting fast changes.</p>\n<pre><code> O      Route 1  /-------------------------------\n/|\\             /\n |  ---------##/\n/ \\            \\\n                \\\n        Route 2  \\--------------------------------\n</code></pre>\n"},{"tags":[],"owner":{"badge_counts":{"bronze":60,"silver":34,"gold":8},"reputation":5478,"user_id":5068056,"user_type":"registered","profile_image":"https://i.stack.imgur.com/m53CE.jpg?s=128&g=1","display_name":"Farhad","link":"https://stackoverflow.com/users/5068056/farhad"},"last_editor":{"badge_counts":{"bronze":103,"silver":60,"gold":6},"reputation":41420,"user_id":3204551,"user_type":"registered","accept_rate":75,"profile_image":"https://www.gravatar.com/avatar/91bb06155f79d40ffecdf124deecb001?s=128&d=identicon&r=PG&f=1","display_name":"Deduplicator","link":"https://stackoverflow.com/users/3204551/deduplicator"},"comment_count":0,"up_vote_count":175,"is_accepted":false,"score":175,"last_activity_date":1610294145,"last_edit_date":1610294145,"creation_date":1507024074,"answer_id":46541691,"question_id":11227809,"content_license":"CC BY-SA 4.0","body":"<p>It's about branch prediction. What is it?</p>\n<ul>\n<li><p>A branch predictor is one of the ancient performance improving techniques which still finds relevance into modern architectures. While the simple prediction techniques provide fast lookup and power efficiency they suffer from a high misprediction rate.</p>\n</li>\n<li><p>On the other hand, complex branch predictions –either neural based or variants of two-level branch prediction –provide better prediction accuracy, but they consume more power and complexity increases exponentially.</p>\n</li>\n<li><p>In addition to this, in complex prediction techniques the time taken to predict the branches is itself very high –ranging from 2 to 5 cycles –which is comparable to the execution time of actual branches.</p>\n</li>\n<li><p>Branch prediction is essentially an optimization (minimization) problem where the emphasis is on to achieve lowest possible miss rate, low power consumption, and low complexity with minimum resources.</p>\n</li>\n</ul>\n<p>There really are three different kinds of branches:</p>\n<p><strong>Forward conditional branches</strong> - based on a run-time condition, the PC (program counter) is changed to point to an address forward in the instruction stream.</p>\n<p><strong>Backward conditional branches</strong> - the PC is changed to point backward in the instruction stream. The branch is based on some condition, such as branching backwards to the beginning of a program loop when a test at the end of the loop states the loop should be executed again.</p>\n<p><strong>Unconditional branches</strong> - this includes jumps, procedure calls and returns that have no specific condition. For example, an unconditional jump instruction might be coded in assembly language as simply &quot;jmp&quot;, and the instruction stream must immediately be directed to the target location pointed to by the jump instruction, whereas a conditional jump that might be coded as &quot;jmpne&quot; would redirect the instruction stream only if the result of a comparison of two values in a previous &quot;compare&quot; instructions shows the values to not be equal. (The segmented addressing scheme used by the x86 architecture adds extra complexity, since jumps can be either &quot;near&quot; (within a segment) or &quot;far&quot; (outside the segment). Each type has different effects on branch prediction algorithms.)</p>\n<p><strong>Static/dynamic Branch Prediction</strong>: Static branch prediction is used by the microprocessor the first time a conditional branch is encountered, and dynamic branch prediction is used for succeeding executions of the conditional branch code.</p>\n<p>References:</p>\n<ul>\n<li><p><em><a href=\"//en.wikipedia.org/wiki/Branch_predictor\" rel=\"noreferrer\">Branch predictor</a></em></p>\n</li>\n<li><p><em><a href=\"//www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm\" rel=\"noreferrer\">A Demonstration of Self-Profiling</a></em></p>\n</li>\n<li><p><em><a href=\"//courses.cs.washington.edu/courses/csep548/06au/lectures/branchPred.pdf\" rel=\"noreferrer\">Branch Prediction Review</a></em></p>\n</li>\n<li><p><em><a href=\"https://web.archive.org/web/20190601170841/https://web.njit.edu/%7Erlopes/Mod5.3.pdf\" rel=\"noreferrer\">Branch Prediction</a> (Using wayback machine)</em></p>\n</li>\n</ul>\n"},{"comments":[{"owner":{"badge_counts":{"bronze":15,"silver":7,"gold":1},"reputation":964,"user_id":1734032,"user_type":"registered","profile_image":"https://i.stack.imgur.com/69zJo.jpg?s=128&g=1","display_name":"mckenzm","link":"https://stackoverflow.com/users/1734032/mckenzm"},"edited":false,"score":3,"creation_date":1564377256,"post_id":47141245,"comment_id":100995393,"content_license":"CC BY-SA 4.0","body":"Almost as good as the Intel marketing animations, and they were obsessed not just with branch prediction but out of order execution, both strategies being &quot;speculative&quot;. Reading ahead in memory and storage (sequential pre-fetch to buffer) is also speculative. It all adds up."},{"owner":{"badge_counts":{"bronze":583,"silver":405,"gold":34},"reputation":236255,"user_id":224132,"user_type":"registered","accept_rate":83,"profile_image":"https://i.stack.imgur.com/N4ivW.png?s=128&g=1","display_name":"Peter Cordes","link":"https://stackoverflow.com/users/224132/peter-cordes"},"reply_to_user":{"badge_counts":{"bronze":15,"silver":7,"gold":1},"reputation":964,"user_id":1734032,"user_type":"registered","profile_image":"https://i.stack.imgur.com/69zJo.jpg?s=128&g=1","display_name":"mckenzm","link":"https://stackoverflow.com/users/1734032/mckenzm"},"edited":false,"score":2,"creation_date":1581307399,"post_id":47141245,"comment_id":106374648,"content_license":"CC BY-SA 4.0","body":"@mckenzm: out-of-order speculative exec makes branch prediction even more valuable; as well as hiding fetch/decode bubbles, branch prediction + speculative exec removes control dependencies from critical path latency.  Code inside or after an <code>if()</code> block can execute <i>before</i> the branch condition is known.  Or for a search loop like <code>strlen</code> or <code>memchr</code>, interations can overlap.  If you had to wait for the match-or-not result to be known before running any of the next iteration, you&#39;d bottleneck on cache load + ALU latency instead of throughput."},{"owner":{"badge_counts":{"bronze":11,"silver":1,"gold":0},"reputation":96,"user_id":13830841,"user_type":"registered","profile_image":"https://lh3.googleusercontent.com/a-/AOh14GiTKeJoO6XlvqYIKBwy8DomvzAr7NzTIFGCxDZw=k-s128","display_name":"Hanna Mcquaig","link":"https://stackoverflow.com/users/13830841/hanna-mcquaig"},"edited":false,"score":1,"creation_date":1593562749,"post_id":47141245,"comment_id":110823751,"content_license":"CC BY-SA 4.0","body":"Did you make the example app in JavaFX?"},{"owner":{"badge_counts":{"bronze":51,"silver":34,"gold":3},"reputation":8297,"user_id":3378204,"user_type":"registered","accept_rate":91,"profile_image":"https://i.stack.imgur.com/jrjpD.png?s=128&g=1","display_name":"Eugene","link":"https://stackoverflow.com/users/3378204/eugene"},"reply_to_user":{"badge_counts":{"bronze":11,"silver":1,"gold":0},"reputation":96,"user_id":13830841,"user_type":"registered","profile_image":"https://lh3.googleusercontent.com/a-/AOh14GiTKeJoO6XlvqYIKBwy8DomvzAr7NzTIFGCxDZw=k-s128","display_name":"Hanna Mcquaig","link":"https://stackoverflow.com/users/13830841/hanna-mcquaig"},"edited":false,"score":1,"creation_date":1593566091,"post_id":47141245,"comment_id":110824362,"content_license":"CC BY-SA 4.0","body":"@HannaMcquaig No, it&#39;s made by Swing. The code is available at <a href=\"https://github.com/Eugene-Mark/branch-predictor-demo\" rel=\"nofollow noreferrer\">github.com/Eugene-Mark/branch-predictor-demo</a>."}],"tags":[],"owner":{"badge_counts":{"bronze":51,"silver":34,"gold":3},"reputation":8297,"user_id":3378204,"user_type":"registered","accept_rate":91,"profile_image":"https://i.stack.imgur.com/jrjpD.png?s=128&g=1","display_name":"Eugene","link":"https://stackoverflow.com/users/3378204/eugene"},"last_editor":{"badge_counts":{"bronze":51,"silver":34,"gold":3},"reputation":8297,"user_id":3378204,"user_type":"registered","accept_rate":91,"profile_image":"https://i.stack.imgur.com/jrjpD.png?s=128&g=1","display_name":"Eugene","link":"https://stackoverflow.com/users/3378204/eugene"},"comment_count":4,"up_vote_count":318,"is_accepted":false,"score":319,"last_activity_date":1581300329,"last_edit_date":1581300329,"creation_date":1509984916,"answer_id":47141245,"question_id":11227809,"content_license":"CC BY-SA 4.0","body":"<p>As what has already been mentioned by others, what behind the mystery is <a href=\"https://en.wikipedia.org/wiki/Branch_predictor\" rel=\"noreferrer\">Branch Predictor</a>. </p>\n\n<p>I'm not trying to add something but explaining the concept in another way. \nThere is a concise introduction on the wiki which contains text and diagram.\nI do like the explanation below which uses a diagram to elaborate the Branch Predictor intuitively.</p>\n\n<blockquote>\n  <p>In computer architecture, a branch predictor is a\n  digital circuit that tries to guess which way a branch (e.g. an\n  if-then-else structure) will go before this is known for sure. The\n  purpose of the branch predictor is to improve the flow in the\n  instruction pipeline. Branch predictors play a critical role in\n  achieving high effective performance in many modern pipelined\n  microprocessor architectures such as x86.</p>\n  \n  <p>Two-way branching is usually implemented with a conditional jump\n  instruction. A conditional jump can either be \"not taken\" and continue\n  execution with the first branch of code which follows immediately\n  after the conditional jump, or it can be \"taken\" and jump to a\n  different place in program memory where the second branch of code is\n  stored. It is not known for certain whether a conditional jump will be\n  taken or not taken until the condition has been calculated and the\n  conditional jump has passed the execution stage in the instruction\n  pipeline (see fig. 1).</p>\n</blockquote>\n\n<p><a href=\"https://i.stack.imgur.com/unxnb.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/unxnb.png\" alt=\"figure 1\"></a></p>\n\n<p>Based on the described scenario, I have written an animation demo to show how instructions are executed in a pipeline in different situations.</p>\n\n<ol>\n<li>Without the Branch Predictor. </li>\n</ol>\n\n<blockquote>\n  <p>Without branch prediction, the processor would have to wait until the\n  conditional jump instruction has passed the execute stage before the\n  next instruction can enter the fetch stage in the pipeline.</p>\n</blockquote>\n\n<p>The example contains three instructions and the first one is a conditional jump instruction. The latter two instructions can go into the pipeline until the conditional jump instruction is executed. </p>\n\n<p><a href=\"https://i.stack.imgur.com/GMFQ6.gif\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/GMFQ6.gif\" alt=\"without branch predictor\"></a></p>\n\n<p>It will take 9 clock cycles for 3 instructions to be completed.</p>\n\n<ol start=\"2\">\n<li>Use Branch Predictor and don't take a conditional jump. Let's assume that the predict is <strong>not</strong> taking the conditional jump.</li>\n</ol>\n\n<p><a href=\"https://i.stack.imgur.com/Ms5p1.gif\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/Ms5p1.gif\" alt=\"enter image description here\"></a></p>\n\n<p>It will take 7 clock cycles for 3 instructions to be completed.</p>\n\n<ol start=\"3\">\n<li>Use Branch Predictor and take a conditional jump. Let's assume that the predict is <strong>not</strong> taking the conditional jump.</li>\n</ol>\n\n<p><a href=\"https://i.stack.imgur.com/HIpG3.gif\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/HIpG3.gif\" alt=\"enter image description here\"></a></p>\n\n<p>It will take 9 clock cycles for 3 instructions to be completed.</p>\n\n<blockquote>\n  <p>The time that is wasted in case of a branch misprediction is equal to\n  the number of stages in the pipeline from the fetch stage to the\n  execute stage. Modern microprocessors tend to have quite long\n  pipelines so that the misprediction delay is between 10 and 20 clock\n  cycles. As a result, making a pipeline longer increases the need for a\n  more advanced branch predictor.</p>\n</blockquote>\n\n<p>As you can see, it seems we don't have a reason not to use Branch Predictor.</p>\n\n<p>It's quite a simple demo that clarifies the very basic part of Branch Predictor. If those gifs are annoying, please feel free to remove them from the answer and visitors can also get the live demo source code from <a href=\"https://github.com/Eugene-Mark/BranchPredictorDemo\" rel=\"noreferrer\">BranchPredictorDemo</a></p>\n"},{"comments":[{"owner":{"badge_counts":{"bronze":26,"silver":29,"gold":2},"reputation":5832,"user_id":3950982,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/7491f45ae073ed6bfe01b1e63fb06bf0?s=128&d=identicon&r=PG","display_name":"Luke Hutchison","link":"https://stackoverflow.com/users/3950982/luke-hutchison"},"edited":false,"score":1,"creation_date":1541507309,"post_id":47457772,"comment_id":93233390,"content_license":"CC BY-SA 4.0","body":"Right, but the setup cost of sorting the array is O(N log N), so breaking early doesn&#39;t help you if the only reason you are sorting the array is to be able to break early. If, however, you have other reasons to pre-sort the array, then yes, this is valuable."},{"owner":{"badge_counts":{"bronze":178,"silver":134,"gold":21},"reputation":44438,"user_id":536086,"user_type":"registered","accept_rate":90,"profile_image":"https://www.gravatar.com/avatar/75d228bb162b779392a94d9364969208?s=128&d=identicon&r=PG","display_name":"Yochai Timmer","link":"https://stackoverflow.com/users/536086/yochai-timmer"},"edited":false,"score":0,"creation_date":1551270202,"post_id":47457772,"comment_id":96577845,"content_license":"CC BY-SA 4.0","body":"Depends how many times you sort the data compared to how many times you loop on it. The sort in this example is just an example, it doesn&#39;t have to be just before the loop"},{"owner":{"badge_counts":{"bronze":26,"silver":29,"gold":2},"reputation":5832,"user_id":3950982,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/7491f45ae073ed6bfe01b1e63fb06bf0?s=128&d=identicon&r=PG","display_name":"Luke Hutchison","link":"https://stackoverflow.com/users/3950982/luke-hutchison"},"edited":false,"score":2,"creation_date":1551356894,"post_id":47457772,"comment_id":96616030,"content_license":"CC BY-SA 4.0","body":"Yes, that&#39;s exactly the point I made in my first comment :-) You say &quot;The branch prediction will miss only once.&quot; But you are not counting the O(N log N) branch prediction misses inside the sort algorithm, which is actually greater than the O(N) branch prediction misses in the unsorted case. So you would need to use the entirety of the sorted data O(log N) times to break even (probably actually closer to O(10 log N), depending on the sort algorithm, e.g. for quicksort, due to cache misses -- mergesort is more cache-coherent, so you would need closer to O(2 log N) usages to break even.)"},{"owner":{"badge_counts":{"bronze":26,"silver":29,"gold":2},"reputation":5832,"user_id":3950982,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/7491f45ae073ed6bfe01b1e63fb06bf0?s=128&d=identicon&r=PG","display_name":"Luke Hutchison","link":"https://stackoverflow.com/users/3950982/luke-hutchison"},"edited":false,"score":0,"creation_date":1551357288,"post_id":47457772,"comment_id":96616273,"content_license":"CC BY-SA 4.0","body":"One significant optimization though would be to do only &quot;half a quicksort&quot;, sorting only items less than the target pivot value of 127 (assuming everything less than <i>or equal to</i> the pivot is sorted after the pivot). Once you reach the pivot, sum the elements before the pivot. This would run in O(N) startup time rather than O(N log N), although there will still be a lot of branch prediction misses, probably of the order of O(5 N) based on the numbers I gave before, since it&#39;s half a quicksort."}],"tags":[],"owner":{"badge_counts":{"bronze":178,"silver":134,"gold":21},"reputation":44438,"user_id":536086,"user_type":"registered","accept_rate":90,"profile_image":"https://www.gravatar.com/avatar/75d228bb162b779392a94d9364969208?s=128&d=identicon&r=PG","display_name":"Yochai Timmer","link":"https://stackoverflow.com/users/536086/yochai-timmer"},"last_editor":{"badge_counts":{"bronze":178,"silver":134,"gold":21},"reputation":44438,"user_id":536086,"user_type":"registered","accept_rate":90,"profile_image":"https://www.gravatar.com/avatar/75d228bb162b779392a94d9364969208?s=128&d=identicon&r=PG","display_name":"Yochai Timmer","link":"https://stackoverflow.com/users/536086/yochai-timmer"},"comment_count":4,"up_vote_count":180,"is_accepted":false,"score":178,"last_activity_date":1551779920,"last_edit_date":1551779920,"creation_date":1511447309,"answer_id":47457772,"question_id":11227809,"content_license":"CC BY-SA 4.0","body":"<p>Besides the fact that the branch prediction may slow you down, a sorted array has another advantage:   </p>\n\n<p>You can have a stop condition instead of just checking the value, this way you only loop over the relevant data, and ignore the rest.<br>\nThe branch prediction will miss only once.</p>\n\n<pre><code> // sort backwards (higher values first), may be in some other part of the code\n std::sort(data, data + arraySize, std::greater&lt;int&gt;());\n\n for (unsigned c = 0; c &lt; arraySize; ++c) {\n       if (data[c] &lt; 128) {\n              break;\n       }\n       sum += data[c];               \n }\n</code></pre>\n"},{"tags":[],"owner":{"badge_counts":{"bronze":21,"silver":6,"gold":1},"reputation":2168,"user_id":8459055,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/ffdc4d783c65c0ab6ff327551fb953c4?s=128&d=identicon&r=PG&f=1","display_name":"omkaartg","link":"https://stackoverflow.com/users/8459055/omkaartg"},"last_editor":{"badge_counts":{"bronze":103,"silver":60,"gold":6},"reputation":41420,"user_id":3204551,"user_type":"registered","accept_rate":75,"profile_image":"https://www.gravatar.com/avatar/91bb06155f79d40ffecdf124deecb001?s=128&d=identicon&r=PG&f=1","display_name":"Deduplicator","link":"https://stackoverflow.com/users/3204551/deduplicator"},"comment_count":0,"up_vote_count":175,"is_accepted":false,"score":158,"last_activity_date":1610294342,"last_edit_date":1610294342,"creation_date":1512667709,"answer_id":47700573,"question_id":11227809,"content_license":"CC BY-SA 4.0","body":"<p>Sorted arrays are processed faster than an unsorted array, due to a phenomena called branch prediction.</p>\n<p>The branch predictor is a digital circuit (in computer architecture) trying to predict which way a branch will go, improving the flow in the instruction pipeline. The circuit/computer predicts the next step and executes it.</p>\n<p>Making a wrong prediction leads to going back to the previous step, and executing with another prediction. Assuming the prediction is correct, the code will continue to the next step. A wrong prediction results in repeating the same step, until a correct prediction occurs.</p>\n<p>The answer to your question is very simple.</p>\n<p>In an unsorted array, the computer makes multiple predictions, leading to an increased chance of errors.\nWhereas, in a sorted array, the computer makes fewer predictions, reducing the chance of errors.\nMaking more predictions requires more time.</p>\n<p>Sorted Array: Straight Road</p>\n<pre class=\"lang-none prettyprint-override\"><code>____________________________________________________________________________________\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT\n</code></pre>\n<p>Unsorted Array: Curved Road</p>\n<pre><code>______   ________\n|     |__|\n</code></pre>\n<p>Branch prediction: Guessing/predicting which road is straight and following it without checking</p>\n<pre><code>___________________________________________ Straight road\n |_________________________________________|Longer road\n</code></pre>\n<p>Although both the roads reach the same destination, the straight road is shorter, and the other is longer. If then you choose the other by mistake, there is no turning back, and so you will waste some extra time if you choose the longer road. This is similar to what happens in the computer, and I hope this helped you understand better.</p>\n<hr />\n<p>Also I want to cite <a href=\"/u/16940\">@Simon_Weaver</a> from the comments:</p>\n<blockquote>\n<p>It doesn’t make fewer predictions - it makes fewer incorrect predictions. It still has to predict for each time through the loop...</p>\n</blockquote>\n"},{"comments":[{"owner":{"badge_counts":{"bronze":26,"silver":29,"gold":2},"reputation":5832,"user_id":3950982,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/7491f45ae073ed6bfe01b1e63fb06bf0?s=128&d=identicon&r=PG","display_name":"Luke Hutchison","link":"https://stackoverflow.com/users/3950982/luke-hutchison"},"reply_to_user":{"badge_counts":{"bronze":82,"silver":32,"gold":4},"reputation":5638,"user_id":712526,"user_type":"registered","accept_rate":50,"profile_image":"https://www.gravatar.com/avatar/06e3c4065e9d08da698b4f4de3959294?s=128&d=identicon&r=PG","display_name":"jpaugh","link":"https://stackoverflow.com/users/712526/jpaugh"},"edited":false,"score":1,"creation_date":1526404014,"post_id":47942152,"comment_id":87727753,"content_license":"CC BY-SA 4.0","body":"The other innovation in ARM is the addition of the S instruction suffix, also optional on (almost) all instructions, which if absent, prevents instructions from changing status bits (with the exception of the CMP instruction, whose job is to set status bits, so it doesn&#39;t need the S suffix). This allows you to avoid CMP instructions in many cases, as long as the comparison is with zero or similar (eg. SUBS R0, R0, #1 will set the Z (Zero) bit when R0 reaches zero). Conditionals and the S suffix incur zero overhead. It&#39;s quite a beautiful ISA."},{"owner":{"badge_counts":{"bronze":26,"silver":29,"gold":2},"reputation":5832,"user_id":3950982,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/7491f45ae073ed6bfe01b1e63fb06bf0?s=128&d=identicon&r=PG","display_name":"Luke Hutchison","link":"https://stackoverflow.com/users/3950982/luke-hutchison"},"reply_to_user":{"badge_counts":{"bronze":82,"silver":32,"gold":4},"reputation":5638,"user_id":712526,"user_type":"registered","accept_rate":50,"profile_image":"https://www.gravatar.com/avatar/06e3c4065e9d08da698b4f4de3959294?s=128&d=identicon&r=PG","display_name":"jpaugh","link":"https://stackoverflow.com/users/712526/jpaugh"},"edited":false,"score":2,"creation_date":1526404102,"post_id":47942152,"comment_id":87727802,"content_license":"CC BY-SA 4.0","body":"Not adding the S suffix allows you to have several conditional instructions in a row without worrying that one of them might change the status bits, which might otherwise have the side effect of skipping the rest of the conditional instructions."},{"owner":{"badge_counts":{"bronze":583,"silver":405,"gold":34},"reputation":236255,"user_id":224132,"user_type":"registered","accept_rate":83,"profile_image":"https://i.stack.imgur.com/N4ivW.png?s=128&g=1","display_name":"Peter Cordes","link":"https://stackoverflow.com/users/224132/peter-cordes"},"edited":false,"score":0,"creation_date":1582284859,"post_id":47942152,"comment_id":106733423,"content_license":"CC BY-SA 4.0","body":"Note that the OP is <i>not</i> including the time to sort in their measurement.  It&#39;s probably an overall loss to sort first before running a branch x86 loop, too, even though the non-sorted case makes the loop run a lot slower.  But sorting a big array requires a <i>lot</i> of work."},{"owner":{"badge_counts":{"bronze":583,"silver":405,"gold":34},"reputation":236255,"user_id":224132,"user_type":"registered","accept_rate":83,"profile_image":"https://i.stack.imgur.com/N4ivW.png?s=128&g=1","display_name":"Peter Cordes","link":"https://stackoverflow.com/users/224132/peter-cordes"},"edited":false,"score":1,"creation_date":1582285008,"post_id":47942152,"comment_id":106733504,"content_license":"CC BY-SA 4.0","body":"BTW, you could save an instruction in the loop by indexing relative to the end of the array.  Before the loop, set up <code>R2 = data + arraySize</code>, then start with <code>R1 = -arraySize</code>.  The bottom of the loop becomes <code>adds r1, r1, #1</code> / <code>bnz inner_loop</code>.  Compilers don&#39;t use this optimization for some reason :/  But anyway, predicated execution of the add is not fundamentally different in this case from what you can do with branchless code on other ISAs, like x86 <code>cmov</code>.  Although it&#39;s not as nice: <a href=\"//stackoverflow.com/q/28875325\">gcc optimization flag -O3 makes code slower than -O2</a>"},{"owner":{"badge_counts":{"bronze":583,"silver":405,"gold":34},"reputation":236255,"user_id":224132,"user_type":"registered","accept_rate":83,"profile_image":"https://i.stack.imgur.com/N4ivW.png?s=128&g=1","display_name":"Peter Cordes","link":"https://stackoverflow.com/users/224132/peter-cordes"},"edited":false,"score":1,"creation_date":1582285220,"post_id":47942152,"comment_id":106733620,"content_license":"CC BY-SA 4.0","body":"(ARM predicated execution truly NOPs the instruction, so you can even use it on loads or stores that would fault, unlike x86 <code>cmov</code> with a memory source operand.  Most ISAs, including AArch64, only have ALU select operations.  So ARM predication can be powerful, and usable more efficiently than branchless code on most ISAs.)"}],"tags":[],"owner":{"badge_counts":{"bronze":26,"silver":29,"gold":2},"reputation":5832,"user_id":3950982,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/7491f45ae073ed6bfe01b1e63fb06bf0?s=128&d=identicon&r=PG","display_name":"Luke Hutchison","link":"https://stackoverflow.com/users/3950982/luke-hutchison"},"last_editor":{"badge_counts":{"bronze":26,"silver":29,"gold":2},"reputation":5832,"user_id":3950982,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/7491f45ae073ed6bfe01b1e63fb06bf0?s=128&d=identicon&r=PG","display_name":"Luke Hutchison","link":"https://stackoverflow.com/users/3950982/luke-hutchison"},"comment_count":5,"up_vote_count":209,"is_accepted":false,"score":208,"last_activity_date":1603233212,"last_edit_date":1603233212,"creation_date":1513948385,"answer_id":47942152,"question_id":11227809,"content_license":"CC BY-SA 4.0","body":"<p>On ARM, there is no branch needed, because every instruction has a 4-bit condition field, which tests (at zero cost) any of <a href=\"https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/condition-codes-1-condition-flags-and-codes\" rel=\"noreferrer\">16 different different conditions</a> that may arise in the Processor Status Register, and if the condition on an instruction is false, the instruction is skipped. This eliminates the need for short branches, and there would be no branch prediction hit for this algorithm. <b>Therefore, the sorted version of this algorithm would run slower than the unsorted version on ARM, because of the extra overhead of sorting.</b></p>\n<p>The inner loop for this algorithm would look something like the following in ARM assembly language:</p>\n<pre class=\"lang-js prettyprint-override\"><code>MOV R0, #0   // R0 = sum = 0\nMOV R1, #0   // R1 = c = 0\nADR R2, data // R2 = addr of data array (put this instruction outside outer loop)\n.inner_loop  // Inner loop branch label\n    LDRB R3, [R2, R1]   // R3 = data[c]\n    CMP R3, #128        // compare R3 to 128\n    ADDGE R0, R0, R3    // if R3 &gt;= 128, then sum += data[c] -- no branch needed!\n    ADD R1, R1, #1      // c++\n    CMP R1, #arraySize  // compare c to arraySize\n    BLT inner_loop      // Branch to inner_loop if c &lt; arraySize\n</code></pre>\n<p><em><strong>But this is actually part of a bigger picture:</strong></em></p>\n<p><code>CMP</code> opcodes always update the status bits in the Processor Status Register (PSR), because that is their purpose, but most other instructions do not touch the PSR unless you add an optional <code>S</code> suffix to the instruction, specifying that the PSR should be updated based on the result of the instruction. <strong>Just like the 4-bit condition suffix, being able to execute instructions without affecting the PSR is a mechanism that reduces the need for branches on ARM, and also facilitates out of order dispatch at the hardware level</strong>, because after performing some operation X that updates the status bits, subsequently (or in parallel) you can do a bunch of other work that explicitly should not affect (or be affected by) the status bits, then you can test the state of the status bits set earlier by X.</p>\n<p>The condition testing field and the optional &quot;set status bit&quot; field can be combined, for example:</p>\n<ul>\n<li><code>ADD R1, R2, R3</code> performs <code>R1 = R2 + R3</code> without updating any status bits.</li>\n<li><code>ADDGE R1, R2, R3</code> performs the same operation only if a previous instruction that affected the status bits resulted in a Greater than or Equal condition.</li>\n<li><code>ADDS R1, R2, R3</code> performs the addition and then updates the <code>N</code>, <code>Z</code>, <code>C</code> and <code>V</code> flags in the Processor Status Register based on whether the result was Negative, Zero, Carried (for unsigned addition), or oVerflowed (for signed addition).</li>\n<li><code>ADDSGE R1, R2, R3</code> performs the addition only if the <code>GE</code> test is true, and then subsequently updates the status bits based on the result of the addition.</li>\n</ul>\n<p>Most processor architectures do not have this ability to specify whether or not the status bits should be updated for a given operation, which can necessitate writing additional code to save and later restore status bits, or may require additional branches, or may limit the processor's out of order execution efficiency: one of the side effects of most CPU instruction set architectures forcibly updating status bits after most instructions is that it is much harder to tease apart which instructions can be run in parallel without interfering with each other. Updating status bits has side effects, therefore has a linearizing effect on code. <strong>ARM's ability to mix and match branch-free condition testing on any instruction with the option to either update or not update the status bits after any instruction is extremely powerful, for both assembly language programmers and compilers, and produces very efficient code.</strong></p>\n<p>When you don't have to branch, you can avoid the time cost of flushing the pipeline for what would otherwise be short branches, and you can avoid the design complexity of many forms of speculative evalution. The performance impact of the initial naive imlementations of the mitigations for many recently discovered processor vulnerabilities (Spectre etc.) shows you just how much the performance of modern processors depends upon complex speculative evaluation logic. With a short pipeline and the dramatically reduced need for branching, ARM just doesn't need to rely on speculative evaluation as much as CISC processors. (Of course high-end ARM implementations do include speculative evaluation, but it's a smaller part of the performance story.)</p>\n<p>If you have ever wondered why ARM has been so phenomenally successful, the brilliant effectiveness and interplay of these two mechanisms (combined with another mechanism that lets you &quot;barrel shift&quot; left or right one of the two arguments of any arithmetic operator or offset memory access operator at zero additional cost) are a big part of the story, because they are some of the greatest sources of the ARM architecture's efficiency. The brilliance of the original designers of the ARM ISA back in 1983, Steve Furber and Roger (now Sophie) Wilson, cannot be overstated.</p>\n"},{"comments":[{"owner":{"badge_counts":{"bronze":26,"silver":29,"gold":2},"reputation":5832,"user_id":3950982,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/7491f45ae073ed6bfe01b1e63fb06bf0?s=128&d=identicon&r=PG","display_name":"Luke Hutchison","link":"https://stackoverflow.com/users/3950982/luke-hutchison"},"edited":false,"score":4,"creation_date":1551356309,"post_id":53689911,"comment_id":96615671,"content_license":"CC BY-SA 4.0","body":"I don&#39;t really see how this proves anything? The only thing you have shown is that &quot;not doing all the work of sorting the whole array takes less time than sorting the whole array&quot;. Your claim that this &quot;also runs fastest&quot; is very architecture-dependent. See my answer about how this works on ARM. PS you could make your code faster on non-ARM architectures by putting the summation inside the 200-element block loop, sorting in reverse, and then using Yochai Timmer&#39;s suggestion of breaking once you get an out-of range value. That way each 200-element block summation can be terminated early."},{"owner":{"badge_counts":{"bronze":583,"silver":405,"gold":34},"reputation":236255,"user_id":224132,"user_type":"registered","accept_rate":83,"profile_image":"https://i.stack.imgur.com/N4ivW.png?s=128&g=1","display_name":"Peter Cordes","link":"https://stackoverflow.com/users/224132/peter-cordes"},"edited":false,"score":0,"creation_date":1576248293,"post_id":53689911,"comment_id":104848977,"content_license":"CC BY-SA 4.0","body":"If you just want to implement the algorithm efficiently over unsorted data, you would do that operation branchlessly (and with SIMD, e.g. with x86 <code>pcmpgtb</code> to find elements with their high bit set, then AND to zero smaller elements).  Spending any time actually sorting chunks would be slower.  A branchless version would have data-independent performance, also proving that the cost came from branch misprediction.  Or just use performance counters to observe that directly, like Skylake <code>int_misc.clear_resteer_cycles</code> or <code>int_misc.recovery_cycles</code> to count front-end idle cycles from mispredicts"},{"owner":{"badge_counts":{"bronze":27,"silver":18,"gold":1},"reputation":2066,"user_id":2297550,"user_type":"registered","accept_rate":40,"profile_image":"https://www.gravatar.com/avatar/20092a7b6e8eebf36a9c28951bd2261f?s=128&d=identicon&r=PG","display_name":"user2297550","link":"https://stackoverflow.com/users/2297550/user2297550"},"edited":false,"score":1,"creation_date":1585896266,"post_id":53689911,"comment_id":107930122,"content_license":"CC BY-SA 4.0","body":"Both comments above seem to ignore the general algorithmic issues and complexity, in favor of advocating specialized hardware with special machine instructions. I find the first one particularly petty in that it blithely dismisses the important general insights in this answer in blind favor of specialized machine instructions."}],"tags":[],"owner":{"badge_counts":{"bronze":27,"silver":18,"gold":1},"reputation":2066,"user_id":2297550,"user_type":"registered","accept_rate":40,"profile_image":"https://www.gravatar.com/avatar/20092a7b6e8eebf36a9c28951bd2261f?s=128&d=identicon&r=PG","display_name":"user2297550","link":"https://stackoverflow.com/users/2297550/user2297550"},"last_editor":{"badge_counts":{"bronze":27,"silver":18,"gold":1},"reputation":2066,"user_id":2297550,"user_type":"registered","accept_rate":40,"profile_image":"https://www.gravatar.com/avatar/20092a7b6e8eebf36a9c28951bd2261f?s=128&d=identicon&r=PG","display_name":"user2297550","link":"https://stackoverflow.com/users/2297550/user2297550"},"comment_count":3,"up_vote_count":89,"is_accepted":false,"score":82,"last_activity_date":1562040497,"last_edit_date":1562040497,"creation_date":1544336297,"answer_id":53689911,"question_id":11227809,"content_license":"CC BY-SA 4.0","body":"<p>The assumption by other answers that one needs to sort the data is not correct.</p>\n\n<p>The following code does not sort the entire array, but only 200-element segments of it, and thereby runs the fastest.</p>\n\n<p>Sorting only k-element sections completes the pre-processing in linear time, <code>O(n)</code>, rather than the <code>O(n.log(n))</code> time needed to sort the entire array.</p>\n\n<pre><code>#include &lt;algorithm&gt;\n#include &lt;ctime&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    int data[32768]; const int l = sizeof data / sizeof data[0];\n\n    for (unsigned c = 0; c &lt; l; ++c)\n        data[c] = std::rand() % 256;\n\n    // sort 200-element segments, not the whole array\n    for (unsigned c = 0; c + 200 &lt;= l; c += 200)\n        std::sort(&amp;data[c], &amp;data[c + 200]);\n\n    clock_t start = clock();\n    long long sum = 0;\n\n    for (unsigned i = 0; i &lt; 100000; ++i) {\n        for (unsigned c = 0; c &lt; sizeof data / sizeof(int); ++c) {\n            if (data[c] &gt;= 128)\n                sum += data[c];\n        }\n    }\n\n    std::cout &lt;&lt; static_cast&lt;double&gt;(clock() - start) / CLOCKS_PER_SEC &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"sum = \" &lt;&lt; sum &lt;&lt; std::endl;\n}\n</code></pre>\n\n<p>This also \"proves\" that it has nothing to do with any algorithmic issue such as sort order, and it is indeed branch prediction.</p>\n"},{"tags":[],"owner":{"badge_counts":{"bronze":89,"silver":83,"gold":11},"reputation":44307,"user_id":2011147,"user_type":"registered","profile_image":"https://i.stack.imgur.com/FGRgf.jpg?s=128&g=1","display_name":"Selcuk","link":"https://stackoverflow.com/users/2011147/selcuk"},"last_editor":{"badge_counts":{"bronze":103,"silver":60,"gold":6},"reputation":41420,"user_id":3204551,"user_type":"registered","accept_rate":75,"profile_image":"https://www.gravatar.com/avatar/91bb06155f79d40ffecdf124deecb001?s=128&d=identicon&r=PG&f=1","display_name":"Deduplicator","link":"https://stackoverflow.com/users/3204551/deduplicator"},"comment_count":0,"up_vote_count":68,"is_accepted":false,"community_owned_date":1571096080,"score":68,"last_activity_date":1610294575,"last_edit_date":1610294575,"creation_date":1571096080,"answer_id":58385294,"question_id":11227809,"content_license":"CC BY-SA 4.0","body":"<p><em><a href=\"//stackoverflow.blog/2019/10/11/c-creator-bjarne-stroustrup-answers-our-top-five-c-questions/\">Bjarne Stroustrup's Answer</a> to this question:</em></p>\n<p>That sounds like an interview question. Is it true? How would you know? It is a bad idea to answer questions about efficiency without first doing some measurements, so it is important to know how to measure.</p>\n<p>So, I tried with a vector of a million integers and got:</p>\n<pre class=\"lang-none prettyprint-override\"><code>Already sorted    32995 milliseconds\nShuffled          125944 milliseconds\n\nAlready sorted    18610 milliseconds\nShuffled          133304 milliseconds\n\nAlready sorted    17942 milliseconds\nShuffled          107858 milliseconds\n</code></pre>\n<p>I ran that a few times to be sure. Yes, the phenomenon is real. My key code was:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>void run(vector&lt;int&gt;&amp; v, const string&amp; label)\n{\n    auto t0 = system_clock::now();\n    sort(v.begin(), v.end());\n    auto t1 = system_clock::now();\n    cout &lt;&lt; label\n         &lt;&lt; duration_cast&lt;microseconds&gt;(t1 — t0).count()\n         &lt;&lt; &quot; milliseconds\\n&quot;;\n}\n\nvoid tst()\n{\n    vector&lt;int&gt; v(1'000'000);\n    iota(v.begin(), v.end(), 0);\n    run(v, &quot;already sorted &quot;);\n    std::shuffle(v.begin(), v.end(), std::mt19937{ std::random_device{}() });\n    run(v, &quot;shuffled    &quot;);\n}\n</code></pre>\n<p>At least the phenomenon is real with this compiler, standard library, and optimizer settings. Different implementations can and do give different answers. In fact, someone did do a more systematic study (a quick web search will find it) and most implementations show that effect.</p>\n<p>One reason is branch prediction: the key operation in the sort algorithm is <code>“if(v[i] &lt; pivot]) …”</code> or equivalent. For a sorted sequence that test is always true whereas, for a random sequence, the branch chosen varies randomly.</p>\n<p>Another reason is that when the vector is already sorted, we never need to move elements to their correct position. The effect of these little details is the factor of five or six that we saw.</p>\n<p>Quicksort (and sorting in general) is a complex study that has attracted some of the greatest minds of computer science. A good sort function is a result of both choosing a good algorithm and paying attention to hardware performance in its implementation.</p>\n<p>If you want to write efficient code, you need to know a bit about machine architecture.</p>\n"},{"comments":[{"owner":{"badge_counts":{"bronze":583,"silver":405,"gold":34},"reputation":236255,"user_id":224132,"user_type":"registered","accept_rate":83,"profile_image":"https://i.stack.imgur.com/N4ivW.png?s=128&g=1","display_name":"Peter Cordes","link":"https://stackoverflow.com/users/224132/peter-cordes"},"edited":false,"score":0,"creation_date":1576247362,"post_id":58531294,"comment_id":104848500,"content_license":"CC BY-SA 4.0","body":"The instructions stay hot in the CPU&#39;s L1 instruction cache regardless of mispredicts.  The problem is fetching them into the <i>pipeline</i> in the right order, before the immediately-previous instructions have decoded and finished executing."}],"tags":[],"owner":{"badge_counts":{"bronze":19,"silver":10,"gold":1},"reputation":1156,"user_id":3821643,"user_type":"registered","profile_image":"https://www.gravatar.com/avatar/bc25ab7aa68cfa9d7b0ca53a15d5f40c?s=128&d=identicon&r=PG&f=1","display_name":"hatirlatici","link":"https://stackoverflow.com/users/3821643/hatirlatici"},"last_editor":{"badge_counts":{"bronze":123,"silver":94,"gold":21},"reputation":27825,"user_id":63550,"user_type":"registered","accept_rate":78,"profile_image":"https://i.stack.imgur.com/RIZKi.png?s=128&g=1","display_name":"Peter Mortensen","link":"https://stackoverflow.com/users/63550/peter-mortensen"},"comment_count":1,"up_vote_count":62,"is_accepted":false,"score":62,"last_activity_date":1610573038,"last_edit_date":1610573038,"creation_date":1571866540,"answer_id":58531294,"question_id":11227809,"content_license":"CC BY-SA 4.0","body":"<p>This question is rooted in <em>branch prediction models</em> on CPUs. I'd recommend reading this paper:</p>\n<p><a href=\"https://pdfs.semanticscholar.org/5634/4be375cfed0f79cb9d009ac838682e1bace3.pdf\" rel=\"noreferrer\"><strong>Increasing the Instruction Fetch Rate via Multiple Branch Prediction and a Branch Address Cache</strong></a></p>\n<p>When you have sorted elements, the <a href=\"https://en.wikipedia.org/wiki/Instruction_register\" rel=\"noreferrer\">IR</a> can not be bothered to fetch all CPU instructions, again and again. It fetches them from the cache.</p>\n"}],"owner":{"badge_counts":{"bronze":534,"silver":459,"gold":49},"reputation":455342,"user_id":87234,"user_type":"registered","accept_rate":100,"profile_image":"https://i.stack.imgur.com/FkjBe.png?s=128&g=1","display_name":"GManNickG","link":"https://stackoverflow.com/users/87234/gmannickg"},"last_editor":{"badge_counts":{"bronze":34,"silver":12,"gold":1},"reputation":26920,"user_id":5923139,"user_type":"registered","profile_image":"https://i.stack.imgur.com/dvoYw.png?s=128&g=1","display_name":"Aplet123","link":"https://stackoverflow.com/users/5923139/aplet123"},"comment_count":6,"is_answered":true,"view_count":1587573,"favorite_count":11292,"down_vote_count":92,"up_vote_count":25447,"protected_date":1399067470,"accepted_answer_id":11227902,"answer_count":25,"score":25355,"last_activity_date":1611741816,"creation_date":1340805096,"last_edit_date":1611521897,"question_id":11227809,"link":"https://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-processing-an-unsorted-array","title":"Why is processing a sorted array faster than processing an unsorted array?","body":"<p>Here is a piece of C++ code that shows some very peculiar behavior. For some strange reason, sorting the data miraculously makes the code almost six times faster:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;algorithm&gt;\n#include &lt;ctime&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n    // Generate data\n    const unsigned arraySize = 32768;\n    int data[arraySize];\n\n    for (unsigned c = 0; c &lt; arraySize; ++c)\n        data[c] = std::rand() % 256;\n\n    // !!! With this, the next loop runs faster.\n    std::sort(data, data + arraySize);\n\n    // Test\n    clock_t start = clock();\n    long long sum = 0;\n\n    for (unsigned i = 0; i &lt; 100000; ++i)\n    {\n        // Primary loop\n        for (unsigned c = 0; c &lt; arraySize; ++c)\n        {\n            if (data[c] &gt;= 128)\n                sum += data[c];\n        }\n    }\n\n    double elapsedTime = static_cast&lt;double&gt;(clock() - start) / CLOCKS_PER_SEC;\n\n    std::cout &lt;&lt; elapsedTime &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; std::endl;\n}\n</code></pre>\n<ul>\n<li>Without <code>std::sort(data, data + arraySize);</code>, the code runs in 11.54 seconds.</li>\n<li>With the sorted data, the code runs in 1.93 seconds.</li>\n</ul>\n<hr />\n<p>Initially, I thought this might be just a language or compiler anomaly, so I tried Java:</p>\n<pre class=\"lang-java prettyprint-override\"><code>import java.util.Arrays;\nimport java.util.Random;\n\npublic class Main\n{\n    public static void main(String[] args)\n    {\n        // Generate data\n        int arraySize = 32768;\n        int data[] = new int[arraySize];\n\n        Random rnd = new Random(0);\n        for (int c = 0; c &lt; arraySize; ++c)\n        data[c] = rnd.nextInt() % 256;\n\n        // !!! With this, the next loop runs faster\n        Arrays.sort(data);\n\n        // Test\n        long start = System.nanoTime();\n        long sum = 0;\n\n        for (int i = 0; i &lt; 100000; ++i)\n        {\n            // Primary loop\n            for (int c = 0; c &lt; arraySize; ++c)\n            {\n                if (data[c] &gt;= 128)\n                    sum += data[c];\n            }\n        }\n\n        System.out.println((System.nanoTime() - start) / 1000000000.0);\n        System.out.println(&quot;sum = &quot; + sum);\n    }\n}\n</code></pre>\n<p>With a similar but less extreme result.</p>\n<hr />\n<p>My first thought was that sorting brings the data into the <a href=\"https://en.wikipedia.org/wiki/CPU_cache\" rel=\"noreferrer\">cache</a>, but then I thought how silly that was because the array was just generated.</p>\n<ul>\n<li>What is going on?</li>\n<li>Why is processing a sorted array faster than processing an unsorted array?</li>\n</ul>\n<p>The code is summing up some independent terms, so the order should not matter.</p>\n"}],"has_more":false,"quota_max":300,"quota_remaining":257}